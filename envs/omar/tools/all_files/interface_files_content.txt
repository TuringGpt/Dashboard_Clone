=== INTERFACE FILES AND CONTENT ===
Generated on: Sun Aug 17 07:34:59 EEST 2025

======================================
DIRECTORY: ./interface_1
======================================

--------------------------------------
FILE: calculate_future_value.py
FULL PATH: ./interface_1/calculate_future_value.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CalculateFutureValue(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], closing_price_or_nav: float, growth_rate: float, 
               number_of_years: int) -> str:
        
        # Validate inputs
        if closing_price_or_nav <= 0:
            return json.dumps({"success": False, "message": "Closing price or NAV must be positive", "halt": True})
        
        if number_of_years < 0:
            return json.dumps({"success": False, "message": "Number of years must be non-negative", "halt": True})
        
        # Calculate future value using formula: FV = PV * (1 + r)^n
        future_value = round(closing_price_or_nav * ((1 + growth_rate) ** number_of_years), 4)
        
        return json.dumps({"future_value": future_value})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "calculate_future_value",
                "description": "Calculate future value using compound interest formula",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "closing_price_or_nav": {"type": "number", "description": "Closing price of fund or NAV"},
                        "growth_rate": {"type": "number", "description": "Growth rate 'r'"},
                        "number_of_years": {"type": "integer", "description": "Number of years 'n'"}
                    },
                    "required": ["closing_price_or_nav", "growth_rate", "number_of_years"]
                }
            }
        }


--------------------------------------
FILE: calculate_liabilities.py
FULL PATH: ./interface_1/calculate_liabilities.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CalculateLiabilities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_id: str) -> str:
        instrument_prices = data.get('instrument_prices', {})
        
        # Find the most recent instrument price record by instrument_id
        instrument_price = None
        latest_date = None
        
        for price_record in instrument_prices.values():
            if str(price_record.get('instrument_id')) == str(instrument_id):
                record_date = price_record.get('price_date')
                if record_date and (latest_date is None or record_date > latest_date):
                    latest_date = record_date
                    instrument_price = price_record
        
        if instrument_price is None:
            return json.dumps({"success": False, "message": "Instrument not found"})
        
        # Get the closing price (note: field name is 'close_price' not 'closing_price')
        closing_price = instrument_price.get('close_price', 0)
        
        # Validate closing price
        if closing_price <= 0:
            return json.dumps({"success": False, "message": "Instrument closing price must be positive"})
        
        # Calculate liabilities as 1.5% of closing price
        liabilities = round(closing_price * 0.015, 4)

        return json.dumps({"success": True, "liabilities": liabilities, "price_date": latest_date})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "calculate_liabilities",
                "description": "Calculate liabilities as 1.5% of instrument closing price",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_id": {"type": "string", "description": "ID of the instrument"}
                    },
                    "required": ["instrument_id"]
                }
            }
        }

--------------------------------------
FILE: calculate_nav.py
FULL PATH: ./interface_1/calculate_nav.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CalculateNav(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, calculation_date: str) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        funds = data.get("funds", {})
        nav_records = data.get("nav_records", {})
        trades = data.get("trades", {})
        instrument_prices = data.get("instrument_prices", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found", "halt": True})
        
        fund = funds[str(fund_id)]
        
        # Calculate NAV based on fund size and recent trades
        base_nav = float(fund.get("size", 1000000))  # Use fund size as base
        
        # Adjust based on recent trades for this fund
        trade_adjustments = 0
        for trade in trades.values():
            if trade.get("fund_id") == fund_id and trade.get("status") == "executed":
                trade_value = float(trade.get("quantity", 0)) * float(trade.get("price", 0))
                if trade.get("side") == "buy":
                    trade_adjustments += trade_value
                else:
                    trade_adjustments -= trade_value
        
        # Simple NAV calculation: base + 5% growth + trade adjustments
        nav_value = round(base_nav * 1.05 + trade_adjustments, 4)
        
        # Create or update NAV record
        nav_id = generate_id(nav_records)
        timestamp = "2025-10-01T00:00:00"
        
        new_nav_record = {
            "nav_id": nav_id,
            "fund_id": fund_id,
            "nav_date": calculation_date,
            "nav_value": nav_value,
            "updated_at": timestamp
        }
        
        nav_records[str(nav_id)] = new_nav_record
        
        return json.dumps({"nav_value": nav_value, "success": True, "message": "NAV updated"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "calculate_nav",
                "description": "Calculate and update the Net Asset Value 'NAV' for a fund",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "calculation_date": {"type": "string", "description": "Date for NAV calculation"}
                    },
                    "required": ["fund_id", "calculation_date"]
                }
            }
        }


--------------------------------------
FILE: cancel_subscription.py
FULL PATH: ./interface_1/cancel_subscription.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CancelSubscription(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], subscription_id: str) -> str:
        
        subscriptions = data.get("subscriptions", {})
        
        # Validate subscription exists
        if str(subscription_id) not in subscriptions:
            return json.dumps({"error": f"Subscription {subscription_id} not found"})
        
        subscription = subscriptions[str(subscription_id)]
        timestamp = "2025-10-01T00:00:00"
        
        # Update subscription status
        subscription["status"] = "cancelled"
        subscription["updated_at"] = timestamp
        
        return json.dumps({"success": True, "message": "Cancellation complete"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "cancel_subscription",
                "description": "Cancel a subscription",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "subscription_id": {"type": "string", "description": "ID of the subscription to cancel"},
                    },
                    "required": ["subscription_id"]
                }
            }
        }


--------------------------------------
FILE: create_commitment.py
FULL PATH: ./interface_1/create_commitment.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateCommitment(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, fund_id: str, 
               amount: float, due_date: str, compliance_officer_approval: bool) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        investors = data.get("investors", {})
        funds = data.get("funds", {})
        commitments = data.get("commitments", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            return json.dumps({"success": False, "message": "Investor not found"})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found"})
        
        # Validate compliance approval
        if not compliance_officer_approval:
            return json.dumps({"success": False, "message": "Compliance officer approval required"})
        
        # Validate amount
        if amount <= 0:
            return json.dumps({"success": False, "message": "Amount must be positive"})
        
        commitment_id = generate_id(commitments)
        timestamp = "2025-10-01T00:00:00"
        
        new_commitment = {
            "commitment_id": commitment_id,
            "fund_id": fund_id,
            "investor_id": investor_id,
            "commitment_amount": amount,
            "commitment_date": due_date,
            "status": "pending", # Initial status and the status can be updated later to fulfilled
            "updated_at": timestamp
        }
        
        commitments[str(commitment_id)] = new_commitment
        return json.dumps({"commitment_id": str(commitment_id), "success": True, "status": "Pending"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_commitment",
                "description": "Create a new commitment for an investor to a fund",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "amount": {"type": "number", "description": "Commitment amount"},
                        "due_date": {"type": "string", "description": "Due date for the commitment"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"}
                    },
                    "required": ["investor_id", "fund_id", "amount", "due_date", "compliance_officer_approval"]
                }
            }
        }


--------------------------------------
FILE: create_fund.py
FULL PATH: ./interface_1/create_fund.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateFund(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_name: str, fund_type: str,
               initial_size: float, manager_id: str, 
               compliance_officer_review: bool, fund_manager_approval: bool) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if not compliance_officer_review:
            return json.dumps({"error": "Compliance Officer review required. Process halted."})
        
        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        
        funds = data.get("funds", {})
        users = data.get("users", {})
        
        # Validate manager exists
        if str(manager_id) not in users:
            return json.dumps({"error": f"Manager {manager_id} not found"})
        
        # Validate fund type
        valid_types = ["mutual_funds", "exchange_traded_funds", "pension_funds", "private_equity_funds",
                      "hedge_funds", "sovereign_wealth_funds", "money_market_funds", 
                      "real_estate_investment_trusts", "infrastructure_funds", "multi_asset_funds"]
        if fund_type not in valid_types:
            return json.dumps({"error": f"Invalid fund type. Must be one of {valid_types}"})
        
        fund_id = generate_id(funds)
        timestamp = "2025-10-01T00:00:00"
        
        new_fund = {
            "fund_id": fund_id,
            "name": fund_name,
            "fund_type": fund_type,
            "manager_id": int(manager_id),
            "size": initial_size,
            "status": "open", # status can be open, closed, or suspended
            "created_at": timestamp,
            "updated_at": timestamp
        }
        
        funds[str(fund_id)] = new_fund
        return json.dumps({"fund_id": str(fund_id)})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_fund",
                "description": "Create a new fund after approvals",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_name": {"type": "string", "description": "Name of the fund"},
                        "fund_type": {"type": "string", "description": "Type of fund. Must be one of: 'mutual_funds', 'exchange_traded_funds', 'pension_funds', 'private_equity_funds', 'hedge_funds', 'sovereign_wealth_funds', 'money_market_funds', 'real_estate_investment_trusts', 'infrastructure_funds', 'multi_asset_funds'"},
                        "initial_size": {"type": "number", "description": "Initial size of the fund"},
                        "manager_id": {"type": "string", "description": "ID of the fund manager"},
                        "compliance_officer_review": {"type": "boolean", "description": "Compliance Officer review flag (True/False)"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag (True/False)"}
                    },
                    "required": ["fund_name", "fund_type", "initial_size", "manager_id", 
                            "compliance_officer_review", "fund_manager_approval"]
                }
            }
        }


--------------------------------------
FILE: create_subscription.py
FULL PATH: ./interface_1/create_subscription.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateSubscription(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, fund_id: str, amount: float,
               compliance_officer_approval: bool) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        # if not compliance_officer_approval:
        #     return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        investors = data.get("investors", {})
        funds = data.get("funds", {})
        subscriptions = data.get("subscriptions", {})
        
        # Validate entities exist
        if str(investor_id) not in investors:
            return json.dumps({"error": f"Investor {investor_id} not found"})
        if str(fund_id) not in funds:
            return json.dumps({"error": f"Fund {fund_id} not found"})
        
        # Check if fund is open
        if funds[str(fund_id)].get("status") != "open":
            return json.dumps({"error": "Fund is not open for subscriptions"})
        
        subscription_id = generate_id(subscriptions)
        timestamp = "2025-10-01T00:00:00"
        
        # Determine status based on payment details
        status = "pending" if not compliance_officer_approval else "approved"
        
        new_subscription = {
            "subscription_id": subscription_id,
            "fund_id": int(fund_id),
            "investor_id": int(investor_id),
            "amount": amount,
            "status": status,
            "request_assigned_to": 1,  # Default admin
            "request_date": timestamp.split("T")[0],
            "approval_date": timestamp.split("T")[0] if status == "approved" else None,
            "updated_at": timestamp
        }
        
        subscriptions[str(subscription_id)] = new_subscription
        
        return_status = "active" if status == "approved" else "funds_pending"
        return json.dumps({"new_subscription": new_subscription, "status": return_status})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_subscription",
                "description": "Create a new fund subscription",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "amount": {"type": "number", "description": "Subscription amount"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"}
                    },
                    "required": ["investor_id", "fund_id", "amount", "compliance_officer_approval"]
                }
            }
        }


--------------------------------------
FILE: create_upload_document.py
FULL PATH: ./interface_1/create_upload_document.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateUploadDocument(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], user_id: str, 
               size_bytes: int, confidentiality_level: str, file_name: str, 
               file_format: str, report_id: str = None) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        users = data.get("users", {})
        documents = data.get("documents", {})
        
        # Validate user exists
        if str(user_id) not in users:
            return json.dumps({"success": False, "message": "User not found"})
        
        # Validate file format
        valid_formats = ["pdf", "docx", "xlsx", "csv"]
        if file_format.lower() not in valid_formats:
            return json.dumps({"success": False, "message": f"Invalid file format. Must be one of {valid_formats}"})
        
        # Validate confidentiality level
        valid_levels = ["public", "internal", "confidential", "restricted"]
        if confidentiality_level.lower() not in valid_levels:
            return json.dumps({"success": False, "message": f"Invalid confidentiality level. Must be one of {valid_levels}"})
        
        document_id = generate_id(documents)
        timestamp = "2025-10-01T00:00:00"
        
        new_document = {
            "document_id": document_id,
            "name": file_name,
            "type": file_format.lower(),
            "uploaded_by": user_id,
            "upload_date": timestamp,
            "report_id": report_id,
            "size_bytes": size_bytes,
            "status": "available"
        }
        
        documents[str(document_id)] = new_document
        return json.dumps({"doc_id": str(document_id), "status": "available"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_upload_document",
                "description": "Create and upload a document to the system",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "user_id": {"type": "string", "description": "ID of the user uploading the document"},
                        "size_bytes": {"type": "integer", "description": "Size of document in bytes"},
                        "confidentiality_level": {"type": "string", "description": "Confidentiality levels: 'public', 'internal', 'confidential', 'restricted'"},
                        "file_name": {"type": "string", "description": "Name of the file"},
                        "file_format": {"type": "string", "description": "File format: pdf, docx, xlsx, or csv"}
                    },
                    "required": ["user_id", "size_bytes", "confidentiality_level", "file_name", "file_format"]
                }
            }
        }


--------------------------------------
FILE: deactivate_reactivate_instrument.py
FULL PATH: ./interface_1/deactivate_reactivate_instrument.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class DeactivateReactivateInstrument(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_id: str, action: str,
               fund_manager_approval: bool, compliance_officer_approval: bool) -> str:
        
        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        instruments = data.get("instruments", {})
        
        # Validate instrument exists
        if str(instrument_id) not in instruments:
            return json.dumps({"error": f"Instrument {instrument_id} not found"})
        
        # Validate action
        if action not in ["deactivate", "reactivate"]:
            return json.dumps({"error": "Action must be 'deactivate' or 'reactivate'"})
        
        instrument = instruments[str(instrument_id)]
        
        # Update instrument status
        if action == "deactivate":
            instrument["status"] = "inactive"
            message = "Instrument Deactivated"
        else:
            instrument["status"] = "active"
            message = "Instrument Reactivated"
        
        return json.dumps({
            "success": True, 
            "message": message,
            "instrument_id": str(instrument_id)
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "deactivate_reactivate_instrument",
                "description": "Deactivate or reactivate an instrument",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_id": {"type": "string", "description": "ID of the instrument"},
                        "action": {"type": "string", "description": "Action to perform (deactivate or reactivate)"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag (True/False)"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"}
                    },
                    "required": ["instrument_id", "action", "fund_manager_approval", "compliance_officer_approval"]
                }
            }
        }


--------------------------------------
FILE: delete_fund.py
FULL PATH: ./interface_1/delete_fund.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class DeleteFund(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, compliance_officer_approval: bool,
               fund_manager_approval: bool) -> str:
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        
        funds = data.get("funds", {})
        subscriptions = data.get("subscriptions", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"error": f"Fund {fund_id} not found"})
        
        # Check for active subscriptions
        active_subscriptions = [s for s in subscriptions.values() 
                            if s.get("fund_id") == int(fund_id) and s.get("status") == "approved"]
        
        # if active_subscriptions:
        #     return json.dumps({"error": "Cannot delete fund with active subscriptions. Process halted."})
        
        # Delete fund
        del funds[str(fund_id)]
        
        return json.dumps({"success": True, "message": "Fund deleted"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "delete_fund",
                "description": "Delete a fund after required approvals",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund to delete"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag (True/False)"}
                    },
                    "required": ["fund_id", "compliance_officer_approval", "fund_manager_approval"]
                }
            }
        }


--------------------------------------
FILE: execute_trade.py
FULL PATH: ./interface_1/execute_trade.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ExecuteTrade(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, instrument_id: str,
               quantity: float, price_limit: float, trader_id: str,
               fund_manager_approval: bool) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        

        funds = data.get("funds", {})
        users = data.get("users", {})
        trades = data.get("trades", {})
        instruments = data.get("instruments", {})
        
        # Validate entities exist
        if str(fund_id) not in funds:
            return json.dumps({"error": f"Fund {fund_id} not found"})
        if str(trader_id) not in users:
            return json.dumps({"error": f"Trader {trader_id} not found"})
        if str(instrument_id) not in instruments:
            return json.dumps({"error": f"Instrument {instrument_id} not found"})
        
        trade_id = generate_id(trades)
        timestamp = "2025-10-01T00:00:00"
        
        # Determine trade side
        side = "buy" if quantity > 0 else "sell"
        
        new_trade = {
            "trade_id": trade_id,
            "fund_id": int(fund_id),
            "instrument_id": int(instrument_id),
            "trade_date": timestamp,
            "quantity": abs(quantity),
            "price": price_limit,
            "side": side,
            "status": "executed",
            "created_at": timestamp
        }
        
        trades[str(trade_id)] = new_trade
        
        return json.dumps({"trade_id": str(trade_id), "success": True, "message": "Trade executed"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "execute_trade",
                "description": "Execute a trade after required approvals",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "instrument_id": {"type": "string", "description": "ID of the instrument to trade"},
                        "quantity": {"type": "number", "description": "Trade quantity: positive for buy, negative for sell"},
                        "price_limit": {"type": "number", "description": "Price limit"},
                        "trader_id": {"type": "string", "description": "ID of the trader"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag (True/False)"}
                    },
                    "required": ["fund_id", "instrument_id", "quantity", "price_limit", "trader_id", 
                               "fund_manager_approval"]
                }
            }
        }

--------------------------------------
FILE: fulfill_commitment.py
FULL PATH: ./interface_1/fulfill_commitment.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class FulfillCommitment(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], commitment_id: str, payment_receipt_amount: float, 
               payment_date: str, payment_method: str) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        commitments = data.get("commitments", {})
        invoices = data.get("invoices", {})
        payments = data.get("payments", {})
        
        # Validate commitment exists
        if str(commitment_id) not in commitments:
            return json.dumps({"success": False, "message": "Commitment not found", "halt": True})
        
        commitment = commitments[str(commitment_id)]
        
        # Validate payment method
        valid_methods = ["wire", "cheque", "credit_card", "bank_transfer"]
        if payment_method.lower() not in valid_methods:
            return json.dumps({"success": False, "message": f"Invalid payment method. Must be one of {valid_methods}", "halt": True})
        
        # Validate amount
        if payment_receipt_amount <= 0:
            return json.dumps({"success": False, "message": "Payment amount must be positive", "halt": True})
        
        # Create invoice if not exists
        invoice_id = None
        for inv_id, inv in invoices.items():
            if inv.get("commitment_id") == commitment_id:
                invoice_id = inv_id
                break
        
        if not invoice_id:
            invoice_id = generate_id(invoices)
            new_invoice = {
                "invoice_id": invoice_id,
                "commitment_id": commitment_id,
                "invoice_date": payment_date,
                "due_date": payment_date,
                "amount": commitment["commitment_amount"],
                "status": "issued",
                "updated_at": "2025-10-01T00:00:00"
            }
            invoices[str(invoice_id)] = new_invoice
        
        # Create payment record
        payment_id = generate_id(payments)
        timestamp = "2025-10-01T00:00:00"
        
        new_payment = {
            "payment_id": payment_id,
            "invoice_id": str(invoice_id),
            "payment_date": timestamp,
            "amount": payment_receipt_amount,
            "payment_method": payment_method.lower(),
            "status": "completed",
            "created_at": timestamp
        }
        
        payments[str(payment_id)] = new_payment
        
        # Update commitment status
        if payment_receipt_amount >= commitment["commitment_amount"]:
            commitment["status"] = "fulfilled"
            status = "fulfilled"
        else:
            status = "pending"
        
        commitment["updated_at"] = timestamp
        
        # Update invoice status if payment covers full amount
        if payment_receipt_amount >= invoices[str(invoice_id)]["amount"]:
            invoices[str(invoice_id)]["status"] = "paid"
            invoices[str(invoice_id)]["updated_at"] = timestamp
        
        return json.dumps({
            "commitment_id": commitment_id, 
            "success": True, 
            "status": status, 
            "amount": payment_receipt_amount
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "fulfill_commitment",
                "description": "Fulfill a commitment by recording payment receipt",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "commitment_id": {"type": "string", "description": "ID of the commitment"},
                        "payment_receipt_amount": {"type": "number", "description": "Amount received"},
                        "payment_date": {"type": "string", "description": "Date of payment (YYYY-MM-DD)"},
                        "payment_method": {"type": "string", "description": "Method of payment: wire, cheque, credit_card, bank_transfer"}
                    },
                    "required": ["commitment_id", "payment_receipt_amount", "payment_date", "payment_method"]
                }
            }
        }


--------------------------------------
FILE: generate_report.py
FULL PATH: ./interface_1/generate_report.py
--------------------------------------

import json
from typing import Any, Dict, Optional, Tuple
from datetime import datetime
import calendar
import re
from tau_bench.envs.tool import Tool


class GenerateReport(Tool):

    @staticmethod
    def invoke(data: Dict[str, Any], report_type: str, period: str, 
               requester_role: str, fund_id: Optional[str] = None, 
               investor_id: Optional[str] = None) -> str:

        def _parse_period(period: str) -> Tuple[str, str]:
            """Parse reporting period into start_date and end_date (YYYY-MM-DD)."""
            period = str(period).strip().upper() # enforce the period to be a string and uppercase

            # Yearly: "2025"
            if re.fullmatch(r"\d{4}", period):
                year = int(period)
                return f"{year}-01-01", f"{year}-12-31"

            # Monthly: "2025-07"
            if re.fullmatch(r"\d{4}-\d{2}", period):
                year, month = map(int, period.split("-"))
                last_day = calendar.monthrange(year, month)[1]
                return f"{year}-{month:02d}-01", f"{year}-{month:02d}-{last_day}"

            # Snapshot: "2025-10-01"
            if re.fullmatch(r"\d{4}-\d{2}-\d{2}", period):
                return period, period

            # Quarterly: "Q1-2025"
            if re.fullmatch(r"Q[1-4]-\d{4}", period):
                q, year = period.split("-")
                year = int(year)
                q = int(q[1])
                month_start = (q - 1) * 3 + 1
                month_end = month_start + 2
                last_day = calendar.monthrange(year, month_end)[1]
                return f"{year}-{month_start:02d}-01", f"{year}-{month_end:02d}-{last_day}"

            # Half-year: "H1-2025" or "H2-2025"
            if re.fullmatch(r"H[12]-\d{4}", period):
                h, year = period.split("-")
                year = int(year)
                if h == "H1":
                    return f"{year}-01-01", f"{year}-06-30"
                else:
                    return f"{year}-07-01", f"{year}-12-31"

            raise ValueError(f"Unsupported period format: {period}")
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        reports = data.get("reports", {})
        funds = data.get("funds", {})
        investors = data.get("investors", {})
        users = data.get("users", {})
        
        # Validate report type
        valid_types = ["performance", "financial", "holding"]
        report_type = report_type.lower()
        if report_type not in valid_types:
            return json.dumps({"success": False, "message": f"Invalid report type. Must be one of {valid_types}"})
        
        # Map each report type to the allowed role
        role_permissions = {
            "performance": "fund_manager",
            "financial": "finance_officer",
            "holding": "finance_officer"
        }
        
        expected_role = role_permissions[report_type]
        if requester_role.lower() != expected_role:
            return json.dumps({
                "success": False,
                "message": f"{report_type.capitalize()} report can only be generated by a {expected_role}"
            })
        
        # If fund_id provided, validate it exists
        if fund_id and str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found"})
        
        # If investor_id provided, validate it exists
        if investor_id and str(investor_id) not in investors:
            return json.dumps({"success": False, "message": "Investor not found"})
        
        # Find a user with the appropriate role to be the generator
        generated_by = None
        for user_id, user in users.items():
            if user.get("role") == requester_role.lower():
                generated_by = user_id
                break
        
        if not generated_by:
            return json.dumps({"success": False, "message": "No authorized user found to generate report"})
        
        try:
            start_date, end_date = _parse_period(period)
        except ValueError as e:
            return json.dumps({"success": False, "message": str(e)})
        
        report_id = generate_id(reports)
        # timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S")
        timestamp = "2025-10-01T00:00:00"
        # Set fund_id to first available fund if not specified and needed
        if not fund_id and funds:
            fund_id = list(funds.keys())[0]
        
        new_report = {
            "report_id": report_id,
            "fund_id": fund_id,
            "investor_id": investor_id,
            "report_type": report_type,
            "report_start": start_date,
            "report_end": end_date,
            "generated_by": generated_by,
            "status": "completed",
            "created_at": timestamp
        }
        
        reports[str(report_id)] = new_report
        
        return json.dumps({"created_report": new_report})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "generate_report",
                "description": "Generate a report for funds or investors",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "report_type": {"type": "string", "description": "Type of report: performance, financial, holding"},
                        "fund_id": {"type": "string", "description": "ID of the fund 'optional'"},
                        "investor_id": {"type": "string", "description": "ID of the investor 'optional'"},
                        "period": {"type": "string", "description": "Reporting period (YYYY, YYYY-MM, YYYY-MM-DD, Qn-YYYY, Hn-YYYY)"},
                        "requester_role": {"type": "string", "description": "Role of the person requesting the report. The person can be fund_manager or a finance_officer"}
                    },
                    "required": ["report_type", "period", "requester_role"]
                }
            }
        }


--------------------------------------
FILE: get_fund_instruments.py
FULL PATH: ./interface_1/get_fund_instruments.py
--------------------------------------


import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class GetFundInstruments(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str) -> str:
        funds = data.get("funds", {})
        instruments = data.get("instruments", {})
        trades = data.get("trades", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found", "halt": True})
        
        fund_instruments = []
        for trade_id, trade in trades.items():
            if trade.get("fund_id") == fund_id:
                instrument_id = trade.get("instrument_id")
                fund_instruments.append(instruments.get(str(instrument_id), {}))
        
        return json.dumps({"fund_instruments": fund_instruments})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_fund_instruments",
                "description": "Retrieve all instruments associated with a specific fund",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"}
                    },
                    "required": ["fund_id"]
                }
            }
        }

--------------------------------------
FILE: investor_offboarding.py
FULL PATH: ./interface_1/investor_offboarding.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class InvestorOffboarding(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str,
               compliance_officer_approval: bool) -> str:
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        investors = data.get("investors", {})
        subscriptions = data.get("subscriptions", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            return json.dumps({"error": f"Investor {investor_id} not found"})
        
        # Check for active subscriptions
        active_subscriptions = [s for s in subscriptions.values() 
                              if s.get("investor_id") == int(investor_id) and s.get("status") == "approved"]
        
        if active_subscriptions:
            return json.dumps({"error": "Cannot offboard investor with active subscriptions. Process halted."})
        
        # Remove investor (in practice, might just mark as inactive)
        del investors[str(investor_id)]
        
        return json.dumps({"message": "Offboarding complete"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "investor_offboarding",
                "description": "Offboard an investor after compliance approval",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor to offboard"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval for offboarding"}
                    },
                    "required": ["investor_id", "compliance_officer_approval"]
                }
            }
        }


--------------------------------------
FILE: investor_onboarding.py
FULL PATH: ./interface_1/investor_onboarding.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class InvestorOnboarding(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], legal_entity_name: str, incorporation_registration_number: str,
               date_of_incorporation: str, country_of_incorporation: str, registered_business_address: str,
               tax_identification_number: str, source_of_funds_declaration: str, compliance_officer_approval: bool) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        investors = data.get("investors", {})
        
        # Validate source of funds
        valid_sources = ["retained_earnings", "shareholder_capital", "asset_sale", "loan_facility", 
                        "external_investment", "government_grant", "merger_or_acquisition_proceeds",
                        "royalty_or_licensing_income", "dividend_income", "other"]
        if source_of_funds_declaration not in valid_sources:
            return json.dumps({"error": f"Invalid source of funds. Must be one of {valid_sources}"})
        
        investor_id = generate_id(investors)
        timestamp = "2025-10-01T00:00:00"
        
        new_investor = {
            "investor_id": investor_id,
            "name": legal_entity_name,
            "registration_number": incorporation_registration_number,
            "date_of_incorporation": date_of_incorporation,
            "country": country_of_incorporation,
            "address": registered_business_address,
            "tax_id": tax_identification_number,
            "source_of_funds": source_of_funds_declaration,
            "contact_email": "",  # Will need to be provided separately
            "accreditation_status": "accredited",  # Default for institutional investors
            "created_at": timestamp
        }
        
        investors[str(investor_id)] = new_investor
        return json.dumps({"investor_id": str(investor_id)})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "investor_onboarding",
                "description": "Onboard a new institutional investor after compliance checks",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "legal_entity_name": {"type": "string", "description": "Legal entity name"},
                        "incorporation_registration_number": {"type": "string", "description": "Incorporation/registration number"},
                        "date_of_incorporation": {"type": "string", "description": "Date of incorporation (YYYY-MM-DD)"},
                        "country_of_incorporation": {"type": "string", "description": "Country of incorporation"},
                        "registered_business_address": {"type": "string", "description": "Registered business address"},
                        "tax_identification_number": {"type": "string", "description": "Tax identification number"},
                        "source_of_funds_declaration": {"type": "string", "description": "Source of funds declaration. It should be only one of the following: 'retained_earnings', 'shareholder_capital', 'asset_sale', 'loan_facility', 'external_investment', 'government_grant', 'merger_or_acquisition_proceeds', 'royalty_or_licensing_income', 'dividend_income', 'other'"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"}
                    },
                    "required": ["legal_entity_name", "incorporation_registration_number", "date_of_incorporation", 
                               "country_of_incorporation", "registered_business_address", "tax_identification_number",
                               "source_of_funds_declaration", "compliance_officer_approval"]
                }
            }
        }


--------------------------------------
FILE: process_redemption.py
FULL PATH: ./interface_1/process_redemption.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ProcessRedemption(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, fund_id: str, 
               amount_or_units: float, compliance_approval: bool, 
               finance_approval: bool) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        investors = data.get("investors", {})
        funds = data.get("funds", {})
        subscriptions = data.get("subscriptions", {})
        redemptions = data.get("redemptions", {})
        portfolios = data.get("portfolios", {})
        portfolio_holdings = data.get("portfolio_holdings", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            return json.dumps({"success": False, "message": "Investor not found"})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found"})
        
        # Check if fund is open
        if funds[str(fund_id)].get("status") != "open":
            return json.dumps({"success": False, "message": "Fund is not open for redemptions"})
        
        # Validate approvals
        if not compliance_approval or not finance_approval:
            return json.dumps({"success": False, "message": "Required approvals not obtained"})
        
        # Find ALL subscriptions and calculate total (OPTION 1)
        all_subscription_ids = []
        all_subscriptions = []
        total_subscription_amount = 0

        for sub_id, sub in subscriptions.items():
            if (sub.get("investor_id") == investor_id and 
                sub.get("fund_id") == fund_id and 
                sub.get("status") == "approved"):
                all_subscription_ids.append(sub.get("subscription_id"))
                all_subscriptions.append(sub)
                total_subscription_amount += float(sub.get("amount", 0))

        if not all_subscription_ids:
            return json.dumps({"success": False, "message": "No active subscription found for this investor and fund"})

        # Check existing redemptions against ALL subscriptions
        total_redeemed = 0
        for redemption in redemptions.values():
            if (redemption.get("subscription_id") in all_subscription_ids and
                redemption.get("status") in ["approved", "processed"]):
                total_redeemed += float(redemption.get("redemption_amount", 0))
        
        # Calculate available balance
        available_balance = total_subscription_amount - total_redeemed
        
        # Validate sufficient balance
        if available_balance < amount_or_units:
            return json.dumps({
                "success": False, 
                "message": f"Insufficient balance. Available: {available_balance}, Requested: {amount_or_units}"
            })
        
        # Additional validation: Check portfolio holdings if they exist
        investor_portfolio = None
        for portfolio in portfolios.values():
            if portfolio.get("investor_id") == investor_id:
                investor_portfolio = portfolio
                break
        
        if investor_portfolio:
            # Check portfolio holdings for this fund
            fund_holdings = 0
            for holding in portfolio_holdings.values():
                if (holding.get("portfolio_id") == investor_portfolio.get("portfolio_id") and
                    holding.get("fund_id") == fund_id):
                    fund_holdings += float(holding.get("quantity", 0))
            
            # Validate against portfolio holdings if they exist
            if fund_holdings > 0 and fund_holdings < amount_or_units:
                return json.dumps({
                    "success": False, 
                    "message": f"Insufficient holdings in portfolio. Available: {fund_holdings}, Requested: {amount_or_units}"
                })
        
        redemption_id = generate_id(redemptions)
        timestamp = "2025-10-01T00:00:00"
        
        # Use the first subscription for the redemption record (or you could choose differently)
        primary_subscription = all_subscriptions[0]
        
        new_redemption = {
            "redemption_id": redemption_id,
            "subscription_id": primary_subscription.get("subscription_id"),
            "request_date": "2025-10-01",
            "redemption_amount": amount_or_units,
            "status": "approved",
            "processed_date": "2025-10-01",
            "updated_at": timestamp,
            "redemption_fee": round(amount_or_units * 0.01, 2)  # 1% fee
        }
        
        redemptions[str(redemption_id)] = new_redemption
        
        # Update portfolio holdings if they exist
        if investor_portfolio:
            for holding_id, holding in portfolio_holdings.items():
                if (holding.get("portfolio_id") == investor_portfolio.get("portfolio_id") and
                    holding.get("fund_id") == fund_id):
                    # Reduce the holding quantity
                    current_quantity = float(holding.get("quantity", 0))
                    new_quantity = max(0, current_quantity - amount_or_units)
                    holding["quantity"] = new_quantity
                    break
        
        return json.dumps({
            "success": True, 
            "message": "Redemption processed",
            "redemption_id": redemption_id,
            "remaining_balance": available_balance - amount_or_units,
            "debug_info": {
                "total_subscriptions_found": len(all_subscription_ids),
                "total_subscription_amount": total_subscription_amount,
                "total_redeemed_before": total_redeemed,
                "available_balance_before": available_balance
            }
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "process_redemption",
                "description": "Process a redemption request for an investor with balance validation across all subscriptions",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "amount_or_units": {"type": "number", "description": "Amount or units to redeem"},
                        "compliance_approval": {"type": "boolean", "description": "Compliance approval flag (True for approved/False for rejected)"},
                        "finance_approval": {"type": "boolean", "description": "Finance approval flag (True for approved/False for rejected)"}
                    },
                    "required": ["investor_id", "fund_id", "amount_or_units", "compliance_approval", "finance_approval"]
                }
            }
        }

--------------------------------------
FILE: switch_funds.py
FULL PATH: ./interface_1/switch_funds.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class SwitchFunds(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, current_fund_id: str,
               target_fund_id: str, switch_amount: float) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        funds = data.get("funds", {})
        investors = data.get("investors", {})
        subscriptions = data.get("subscriptions", {})
        redemptions = data.get("redemptions", {})
        
        # Validate entities exist
        if str(investor_id) not in investors:
            return json.dumps({"error": f"Investor {investor_id} not found"})
        if str(current_fund_id) not in funds:
            return json.dumps({"error": f"Current fund {current_fund_id} not found"})
        if str(target_fund_id) not in funds:
            return json.dumps({"error": f"Target fund {target_fund_id} not found"})
        
        # Find current subscription
        current_subscription = None
        for sub in subscriptions.values():
            if (sub.get("investor_id") == (investor_id) and # compare a string with string
                sub.get("fund_id") == (current_fund_id) and 
                sub.get("status") == "approved"):
                current_subscription = sub
                break
        
        if not current_subscription:
            return json.dumps({"error": "No active subscription for this investor found in current fund"})
        
        if current_subscription.get("amount", 0) < switch_amount:
            return json.dumps({"error": "Insufficient balance in current fund"})
        
        timestamp = "2025-10-01T00:00:00"
        
        # Create redemption from current fund
        redemption_id = generate_id(redemptions)
        new_redemption = {
            "redemption_id": redemption_id,
            "subscription_id": current_subscription["subscription_id"],
            "request_date": timestamp.split("T")[0],
            "redemption_amount": switch_amount,
            "status": "processed",
            "processed_date": timestamp.split("T")[0],
            "updated_at": timestamp,
            "redemption_fee": 0.0
        }
        redemptions[str(redemption_id)] = new_redemption
        
        # Update current subscription
        current_subscription["amount"] -= switch_amount
        current_subscription["updated_at"] = timestamp
        
        # Create new subscription in target fund
        subscription_id = generate_id(subscriptions)
        new_subscription = {
            "subscription_id": subscription_id,
            "fund_id": int(target_fund_id),
            "investor_id": int(investor_id),
            "amount": switch_amount,
            "status": "approved",
            "request_assigned_to": 1,  # Default admin
            "request_date": timestamp.split("T")[0],
            "approval_date": timestamp.split("T")[0],
            "updated_at": timestamp
        }
        subscriptions[str(subscription_id)] = new_subscription
        
        return json.dumps({"success": True, "message": "Switch complete"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "switch_funds",
                "description": "Switch investor funds between two funds",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "current_fund_id": {"type": "string", "description": "ID of the current fund"},
                        "target_fund_id": {"type": "string", "description": "ID of the target fund"},
                        "switch_amount": {"type": "number", "description": "Amount to switch"}
                    },
                    "required": ["investor_id", "current_fund_id", "target_fund_id", "switch_amount"]
                }
            }
        }


--------------------------------------
FILE: update_fund.py
FULL PATH: ./interface_1/update_fund.py
--------------------------------------

import json
from typing import Any, Dict, Optional, Union
from tau_bench.envs.tool import Tool

class UpdateFund(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, field_name: str, field_value: Union[str, int, float],
               fund_manager_approval: bool, compliance_review_required: Optional[bool] = None,
               compliance_officer_approval: Optional[bool] = None) -> str:

        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        
        if compliance_review_required and not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required for this change. Process halted."})
        
        funds = data.get("funds", {})
        users = data.get("users", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"error": f"Fund {fund_id} not found"})
        
        fund = funds[str(fund_id)]
        
        # Validate field against allowed fields and values
        allowed_fields = ["name", "fund_type", "manager_id", "size", "status"]
        valid_fund_types = ["mutual_funds", "exchange_traded_funds", "pension_funds", 
                           "private_equity_funds", "hedge_funds", "sovereign_wealth_funds", 
                           "money_market_funds", "real_estate_investment_trusts", 
                           "infrastructure_funds", "multi_asset_funds"]
        valid_statuses = ["open", "closed"]

        # Validate field name
        if field_name not in allowed_fields:
            return json.dumps({"error": f"Field '{field_name}' is not allowed to be updated"})

        # Validate specific field values
        if field_name == "fund_type" and field_value not in valid_fund_types:
            return json.dumps({"error": f"Invalid fund_type. Must be one of {valid_fund_types}"})

        if field_name == "status" and field_value not in valid_statuses:
            return json.dumps({"error": f"Invalid status. Must be one of {valid_statuses}"})

        if field_name == "manager_id" and str(field_value) not in users:
            return json.dumps({"error": f"Manager {field_value} not found"})

        if field_name == "size" and (not isinstance(field_value, (int, float)) or field_value < 0):
            return json.dumps({"error": "Fund size must be a non-negative number"})
        
        # Apply change
        timestamp = "2025-10-01T00:00:00"
        original_value = fund.get(field_name)
        
        # Update the field
        fund[field_name] = field_value
        fund["updated_at"] = timestamp
        
        # Create audit trail entry
        audit_trails = data.get("audit_trails", {})
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        # Only create audit trail if value actually changed
        if original_value != field_value:
            audit_id = generate_id(audit_trails)
            audit_record = {
                "audit_trail_id": audit_id,
                "reference_id": int(fund_id),
                "reference_type": "fund",
                "action": "update",
                "user_id": fund.get("manager_id", 1),  # Use manager as the updating user
                "field_name": field_name,
                "old_value": str(original_value) if original_value is not None else None,
                "new_value": str(field_value) if field_value is not None else None,
                "created_at": timestamp
            }
            audit_trails[str(audit_id)] = audit_record
        
        return json.dumps({
            "success": True, 
            "message": "Fund updated successfully",
            "fund_id": fund_id,
            "updated_field": field_name,
            "old_value": original_value,
            "new_value": field_value
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_fund",
                "description": "Update a single fund field with required approvals and audit trail",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund to update"},
                        "field_name": {
                            "type": "string", 
                            "description": "Name of the field to update",
                            "enum": ["name", "fund_type", "manager_id", "size", "status"]
                        },
                        "field_value": {
                            "description": "New value for the field (string, number, or boolean depending on field type)"
                        },
                        "fund_manager_approval": {"type": "boolean", "description": "Fund manager approval required (True or False)"},
                        "compliance_review_required": {"type": "boolean", "description": "Whether compliance review is required for this change (True for all changes)"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance officer approval (required if compliance_review_required is true). Its value is True"}
                    },
                    "required": ["fund_id", "field_name", "field_value", "fund_manager_approval"]
                }
            }
        }

--------------------------------------
FILE: update_instrument.py
FULL PATH: ./interface_1/update_instrument.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class UpdateInstrument(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_id: str, proposed_changes: Dict[str, Any], 
            action, updated_by, compliance_review_required: Optional[bool]) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        instruments = data.get("instruments", {})
        users = data.get("users", {})
        audit_trails = data.get("audit_trails", {})
        
        # Validate instrument exists
        if str(instrument_id) not in instruments:
            return json.dumps({"success": False, "message": "Instrument not found"})
        

        # Validate proposed changes
        if not proposed_changes or not isinstance(proposed_changes, dict):
            return json.dumps({"success": False, "message": "Valid proposed changes required"})
        
        instrument = instruments[str(instrument_id)]
        
        # Check current status and validate action
        current_status = instrument.get("status", "active")
        if action.lower() == "deactivate" and current_status == "inactive":
            return json.dumps({"success": False, "message": "Instrument is already inactive"})
        elif action.lower() == "reactivate" and current_status == "active":
            return json.dumps({"success": False, "message": "Instrument is already active"})

        if not updated_by:
            return json.dumps({"success": False, "message": "No authorized user found to perform action"})
        
        # Update instrument status
        old_status = instrument.get("status")
        new_status = "inactive" if action.lower() == "deactivate" else "active"
        instrument["status"] = new_status
        
        # Create audit trail entry
        audit_id = generate_id(audit_trails)
        timestamp = "2025-10-01T00:00:00"
        
        audit_entry = {
            "audit_trail_id": audit_id,
            "reference_id": instrument_id,
            "reference_type": "instrument",
            "action": 'update',
            "user_id": updated_by,
            "field_name": "status",
            "old_value": old_status,
            "new_value": new_status,
            "created_at": timestamp
        }
        audit_trails[str(audit_id)] = audit_entry
        
        action_past = "Deactivated" if action.lower() == "deactivate" else "Reactivated"
        return json.dumps({
            "success": True, 
            "message": f"Instrument {action_past}", 
            "instrument_id": instrument_id
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "deactivate_reactivate_instrument",
                "description": "Deactivate or reactivate an instrument",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_id": {"type": "string", "description": "ID of the instrument"},
                        "action": {"type": "string", "description": "Action to perform: deactivate or reactivate"},
                        "reason": {"type": "string", "description": "Reason for the action"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag"}
                    },
                    "required": ["instrument_id", "action", "reason", "fund_manager_approval", "compliance_officer_approval"]
                }
            }
        }


--------------------------------------
FILE: update_subscription.py
FULL PATH: ./interface_1/update_subscription.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class UpdateSubscription(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], subscription_id: str, field_name, field_value,
               compliance_officer_approval: bool, finance_officer_approval: bool) -> str:
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        if not finance_officer_approval:
            return json.dumps({"error": "Finance Officer approval required. Process halted."})
        
        subscriptions = data.get("subscriptions", {})
        
        # Validate subscription exists
        if str(subscription_id) not in subscriptions:
            return json.dumps({"error": f"Subscription {subscription_id} not found"})
        
        subscription = subscriptions[str(subscription_id)]
        timestamp = "2025-10-01T00:00:00"
        
        # Apply changes
        if field_name in ["amount", "status"]:
            subscription[field_name] = field_value

        subscription["updated_at"] = timestamp

        return json.dumps({"subscription_after_update": subscription})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_subscription",
                "description": "Update subscription details with required approvals",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "subscription_id": {"type": "string", "description": "ID of the subscription to update"},
                        "field_name": {
                            "type": "string",
                            "description": "Field to update (e.g., 'amount', 'status')"
                        },
                        "field_value": {
                            "type": "any",
                            "description": "New value for the field"
                        },
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"},
                        "finance_officer_approval": {"type": "boolean", "description": "Finance Officer approval flag (True/False)"}
                    },
                    "required": ["subscription_id", "field_name", "field_value", "compliance_officer_approval", "finance_officer_approval"]
                }
            }
        }



======================================
DIRECTORY: ./interface_2
======================================

--------------------------------------
FILE: add_new_trade_for_fund.py
FULL PATH: ./interface_2/add_new_trade_for_fund.py
--------------------------------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool

class AddNewTradeForFund(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, instrument_id: str,
               quantity: float, price: float, side: str, status: str = "pending",
               validate_positions: bool = True) -> str:
        """
        Add a new trade for investment execution with comprehensive validation.
        
        CORRECTED Investment Structure (based on actual DB schema):
        Investors  Portfolios  Portfolio Holdings (fund shares)  Funds  Trades (instruments)
        
        Key relationships:
        - Investors have portfolios
        - Portfolio holdings contain fund shares (not individual instruments)
        - Funds execute trades in instruments
        - Each trade affects the fund's NAV, which affects all investors proportionally
        
        Args:
            data: Main data dictionary
            fund_id: ID of the fund making the trade
            instrument_id: ID of the instrument to trade
            quantity: Trade quantity (must be positive)
            price: Trade price per unit (must be positive)
            side: 'buy' (purchase) or 'sell' (dispose)
            status: Trade status (defaults to 'pending')
            validate_positions: Whether to validate fund capacity and investor impacts
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        def get_fund_investors_via_holdings(fund_id: str) -> List[Dict[str, Any]]:
            """Get all investors who have portfolio holdings in this fund"""
            portfolio_holdings = data.get("portfolio_holdings", {})
            portfolios = data.get("portfolios", {})
            investors = data.get("investors", {})
            fund_investors = []
            
            for holding in portfolio_holdings.values():
                if str(holding.get("fund_id")) == str(fund_id):
                    portfolio_id = holding.get("portfolio_id")
                    # Find the portfolio owner (investor)
                    for portfolio in portfolios.values():
                        if str(portfolio.get("portfolio_id")) == str(portfolio_id):
                            investor_id = portfolio.get("investor_id")
                            if str(investor_id) in investors:
                                investor_info = investors[str(investor_id)].copy()
                                investor_info["portfolio_id"] = portfolio_id
                                investor_info["holding_quantity"] = holding.get("quantity", 0)  # Fund shares
                                investor_info["cost_basis"] = holding.get("cost_basis", 0)
                                fund_investors.append(investor_info)
                            break
            
            return fund_investors
        
        def get_fund_current_nav(fund_id: str) -> float:
            """Get the most recent NAV for the fund"""
            nav_records = data.get("nav_records", {})
            latest_nav = 0.0
            latest_date = None
            
            for nav_record in nav_records.values():
                if str(nav_record.get("fund_id")) == str(fund_id):
                    nav_date = nav_record.get("nav_date")
                    if latest_date is None or nav_date > latest_date:
                        latest_date = nav_date
                        latest_nav = nav_record.get("nav_value", 0.0)
            
            return latest_nav
        
        def get_fund_cash_balance(fund_id: str) -> float:
            """Get available cash balance for a fund"""
            # In real implementation, this would come from fund's cash position
            # For now, estimate from fund size minus current positions
            fund_record = data.get("funds", {}).get(str(fund_id), {})
            fund_size = fund_record.get("size", 0.0)
            
            # Rough estimate: assume some percentage is cash
            # In practice, you'd track actual cash positions
            return fund_size * 0.1  # Assume 10% cash buffer
        
        def get_fund_instrument_position(fund_id: str, instrument_id: str) -> float:
            """Get current position quantity for a fund's instrument from executed trades"""
            trades = data.get("trades", {})
            net_position = 0.0
            
            for trade in trades.values():
                if (str(trade.get("fund_id")) == str(fund_id) and 
                    str(trade.get("instrument_id")) == str(instrument_id) and
                    trade.get("status") == "executed"):
                    
                    quantity = trade.get("quantity", 0.0)
                    if trade.get("side") == "buy":
                        net_position += quantity
                    elif trade.get("side") == "sell":
                        net_position -= quantity
            
            return net_position
        
        def check_investor_impact_warnings(fund_investors: List[Dict], trade_value: float, fund_nav: float) -> List[str]:
            """Check if trade creates warnings for any investors"""
            warnings = []
            
            if fund_nav <= 0:
                warnings.append("Fund NAV is zero or negative - cannot assess investor impact")
                return warnings
            
            trade_impact_percentage = abs(trade_value) / fund_nav
            
            for investor in fund_investors:
                # Check investor status
                if investor.get("status") == "offboarded":
                    warnings.append(f"Investor {investor.get('investor_id')} is offboarded but still has holdings")
                
                # Check accreditation for large trades
                if (investor.get("accreditation_status") == "non_accredited" and 
                    trade_impact_percentage > 0.05):  # 5% threshold
                    warnings.append(f"Large trade may require disclosure to non-accredited investor {investor.get('investor_id')}")
                
                # Check if investor has pending subscriptions/redemptions
                subscriptions = data.get("subscriptions", {})
                redemptions = data.get("redemptions", {})
                
                pending_sub = any(
                    sub.get("investor_id") == investor.get("investor_id") and 
                    sub.get("fund_id") == fund_id and 
                    sub.get("status") == "pending"
                    for sub in subscriptions.values()
                )
                
                pending_red = any(
                    red.get("status") == "pending" and
                    subscriptions.get(str(red.get("subscription_id", "")), {}).get("investor_id") == investor.get("investor_id")
                    for red in redemptions.values()
                )
                
                if pending_sub or pending_red:
                    warnings.append(f"Investor {investor.get('investor_id')} has pending transactions that may be affected")
            
            return warnings
        
        # Validate inputs
        if quantity <= 0:
            raise ValueError("Quantity must be positive")
        
        if price <= 0:
            raise ValueError("Price must be positive")
        
        funds = data.get("funds", {})
        instruments = data.get("instruments", {})
        trades = data.get("trades", {})
        
        # Validate fund exists and is open
        if str(fund_id) not in funds:
            raise ValueError(f"Fund {fund_id} not found")
        
        fund_record = funds[str(fund_id)]
        if fund_record.get("status") != "open":
            raise ValueError(f"Fund {fund_id} is not open for trading (status: {fund_record.get('status')})")
        
        # Validate instrument exists and is active
        if str(instrument_id) not in instruments:
            raise ValueError(f"Instrument {instrument_id} not found")
        
        instrument_record = instruments[str(instrument_id)]
        if instrument_record.get("status") != "active":
            raise ValueError(f"Instrument {instrument_id} is not active (status: {instrument_record.get('status')})")
        
        # Validate side and status
        valid_sides = ["buy", "sell"]
        if side not in valid_sides:
            raise ValueError(f"Invalid side '{side}'. Must be one of {valid_sides}")
        
        valid_statuses = ["approved", "executed", "pending", "failed"]
        if status not in valid_statuses:
            raise ValueError(f"Invalid status '{status}'. Must be one of {valid_statuses}")
        
        # Get fund's investors through portfolio holdings
        fund_investors = get_fund_investors_via_holdings(fund_id)
        if not fund_investors:
            raise ValueError(f"No investors found with holdings in fund {fund_id}. Cannot execute trades for fund without investors.")
        
        trade_value = quantity * price
        warnings = []
        
        # Enhanced validation including investor impact
        if validate_positions:
            current_position = get_fund_instrument_position(fund_id, instrument_id)
            fund_nav = get_fund_current_nav(fund_id)
            
            if side == "buy":
                # Check cash availability
                cash_balance = get_fund_cash_balance(fund_id)
                if trade_value > cash_balance:
                    raise ValueError(
                        f"Insufficient fund cash for purchase. "
                        f"Required: ${trade_value:,.2f}, Available: ${cash_balance:,.2f}"
                    )
                
                # Check if this trade significantly changes fund composition
                if fund_nav > 0 and trade_value > fund_nav * 0.1:  # More than 10% of fund
                    warnings.append(
                        f"Large purchase ({trade_value/fund_nav:.1%} of fund NAV) may require investor notification"
                    )
            
            elif side == "sell":
                if quantity > current_position:
                    if current_position > 0:
                        short_quantity = quantity - current_position
                        warnings.append(
                            f"Partial short sale: selling {short_quantity} shares beyond "
                            f"current position of {current_position}"
                        )
                    else:
                        warnings.append(f"Pure short sale of {quantity} shares")
                        # You might want to check if short selling is allowed
                
                # Check if this significantly reduces a major holding
                if current_position > 0 and quantity >= current_position * 0.5:
                    percentage_sold = (quantity / current_position) * 100
                    warnings.append(
                        f"Selling {percentage_sold:.1f}% of {instrument_record.get('ticker', instrument_id)} "
                        f"position may trigger portfolio rebalancing"
                    )
            
            # Check investor-specific impact warnings
            investor_warnings = check_investor_impact_warnings(fund_investors, trade_value, fund_nav)
            warnings.extend(investor_warnings)
        
        # Generate trade
        trade_id = generate_id(trades)
        timestamp = "2025-10-01T00:00:00"  # In real system, use current timestamp
        
        new_trade = {
            "trade_id": trade_id,
            "fund_id": int(fund_id),
            "instrument_id": int(instrument_id), 
            "trade_date": timestamp,
            "quantity": quantity,
            "price": price,
            "side": side,
            "status": status,
            "created_at": timestamp
        }
        
        trades[str(trade_id)] = new_trade
        
        result = {
            "trade_id": trade_id,
            "status": "created",
            "trade_value": trade_value,
            "affected_investors": len(fund_investors),
            "fund_status": fund_record.get("status"),
            "instrument_ticker": instrument_record.get("ticker", "N/A"),
            "message": f"Trade created: {side.upper()} {quantity} shares of {instrument_record.get('ticker', instrument_id)} at ${price:.2f}",
        }
        
        if warnings:
            result["warnings"] = warnings
        
        return json.dumps(result)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "add_new_trade_for_fund",
                "description": "Add a new trade for fund-level investment execution. Validates fund is open, instrument is active, sufficient cash for buys, and assesses impact on all fund investors through their portfolio holdings.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund making the trade (must be open status)"},
                        "instrument_id": {"type": "string", "description": "ID of the instrument to trade (must be active)"},
                        "quantity": {"type": "number", "description": "Trade quantity (must be positive)"},
                        "price": {"type": "number", "description": "Trade price per unit (must be positive)"},
                        "side": {
                            "type": "string", 
                            "description": "Trade side: 'buy' (purchase) or 'sell' (dispose/short)",
                            "enum": ["buy", "sell"]
                        },
                        "status": {
                            "type": "string", 
                            "description": "Trade status (defaults to 'pending')",
                            "enum": ["approved", "executed", "pending", "failed"]
                        },
                        "validate_positions": {
                            "type": "boolean",
                            "description": "Whether to validate fund positions, cash, and investor impacts (default: true)"
                        }
                    },
                    "required": ["fund_id", "instrument_id", "quantity", "price", "side"]
                }
            }
        }

--------------------------------------
FILE: add_new_user.py
FULL PATH: ./interface_2/add_new_user.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class AddNewUser(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], first_name: str, last_name: str, 
               email: str, role: str, timezone: str, status: str = "active") -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        users = data.get("users", {})
        
        # Check if email already exists
        for user in users.values():
            if user.get("email") == email:
                raise ValueError(f"Email {email} already exists")
        
        # Validate role
        valid_roles = ["system_administrator", "fund_manager", "compliance_officer", 
                      "finance_officer", "trader"]
        if role not in valid_roles:
            raise ValueError(f"Invalid role. Must be one of {valid_roles}")
        
        # Validate status
        valid_statuses = ["active", "inactive", "suspended"]
        if status not in valid_statuses:
            raise ValueError(f"Invalid status. Must be one of {valid_statuses}")
        
        user_id = generate_id(users)
        timestamp = "2025-10-01T00:00:00"
        
        new_user = {
            "user_id": user_id,
            "first_name": first_name,
            "last_name": last_name,
            "email": email,
            "role": role,
            "timezone": timezone,
            "status": status,
            "created_at": timestamp,
            "updated_at": timestamp
        }
        
        users[str(user_id)] = new_user
        return json.dumps({"new_user": new_user})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "add_new_user",
                "description": "Add a new user for staff onboarding",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "first_name": {"type": "string", "description": "User's first name"},
                        "last_name": {"type": "string", "description": "User's last name"},
                        "email": {"type": "string", "description": "User's email address"},
                        "role": {"type": "string", "description": "User role (system_administrator, fund_manager, compliance_officer, finance_officer, trader)"},
                        "timezone": {"type": "string", "description": "User's timezone (e.g., 'UTC', 'America/New_York')"},
                        "status": {"type": "string", "description": "User status (active, inactive, suspended), defaults to active"}
                    },
                    "required": ["first_name", "last_name", "email", "role", "timezone"]
                }
            }
        }


--------------------------------------
FILE: find_user.py
FULL PATH: ./interface_2/find_user.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class FindUser(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], user_id: Optional[str] = None, email: Optional[str] = None,
               role: Optional[str] = None, status: Optional[str] = None,
               first_name: Optional[str] = None, last_name: Optional[str] = None) -> str:
        users = data.get("users", {})
        results = []
        
        for user in users.values():
            if user_id and user.get("user_id") != user_id:
                continue
            if email and user.get("email", "").lower() != email.lower():
                continue
            if role and user.get("role") != role:
                continue
            if status and user.get("status") != status:
                continue
            if first_name and first_name.lower() not in user.get("first_name", "").lower():
                continue
            if last_name and last_name.lower() not in user.get("last_name", "").lower():
                continue
            results.append(user)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "find_user",
                "description": "Find users for lookup and support",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "email": {"type": "string", "description": "Filter by email address"},
                        "role": {"type": "string", "description": "Filter by role (system_administrator, fund_manager, compliance_officer, finance_officer, trader)"},
                        "status": {"type": "string", "description": "Filter by status (active, inactive, suspended)"},
                        "first_name": {"type": "string", "description": "Filter by first name (partial match)"},
                        "last_name": {"type": "string", "description": "Filter by last name (partial match)"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: get_daily_profit_loss_by_fund.py
FULL PATH: ./interface_2/get_daily_profit_loss_by_fund.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetDailyProfitLossByFund(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, trade_date: Optional[str] = None) -> str:
        trades = data.get("trades", {})
        funds = data.get("funds", {})
        results = []
        
        # Validate fund exists
        if str(fund_id) not in funds:
            raise ValueError(f"Fund {fund_id} not found")
        
        daily_pnl = {}
        
        for trade in trades.values():
            if trade.get("fund_id") != fund_id:
                continue
            
            # Extract date from timestamp
            trade_timestamp = trade.get("trade_date", "")
            trade_day = trade_timestamp.split("T")[0] if "T" in trade_timestamp else trade_timestamp
            
            if trade_date and trade_day != trade_date:
                continue
            
            if trade_day not in daily_pnl:
                daily_pnl[trade_day] = {
                    "date": trade_day,
                    "fund_id": fund_id,
                    "total_buy_value": 0,
                    "total_sell_value": 0,
                    "net_pnl": 0,
                    "trade_count": 0
                }
            
            quantity = float(trade.get("quantity", 0))
            price = float(trade.get("price", 0))
            value = quantity * price
            
            if trade.get("side") == "buy":
                daily_pnl[trade_day]["total_buy_value"] += value
            elif trade.get("side") == "sell":
                daily_pnl[trade_day]["total_sell_value"] += value
            
            daily_pnl[trade_day]["trade_count"] += 1
        
        # Calculate net P&L
        for day_data in daily_pnl.values():
            day_data["net_pnl"] = day_data["total_sell_value"] - day_data["total_buy_value"]
            results.append(day_data)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_daily_profit_loss_by_fund",
                "description": "Get daily profit and loss for risk monitoring by fund",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "trade_date": {"type": "string", "description": "Filter by specific trade date (optional)"}
                    },
                    "required": ["fund_id"]
                }
            }
        }


--------------------------------------
FILE: get_fund_trade_details.py
FULL PATH: ./interface_2/get_fund_trade_details.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetFundTradeDetails(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, instrument_id: Optional[str] = None,
               status: Optional[str] = None, side: Optional[str] = None) -> str:
        trades = data.get("trades", {})
        funds = data.get("funds", {})
        results = []
        
        # Validate fund exists
        if str(fund_id) not in funds:
            raise ValueError(f"Fund {fund_id} not found")
        
        for trade in trades.values():
            if trade.get("fund_id") != fund_id:
                continue
            if instrument_id and trade.get("instrument_id") != instrument_id:
                continue
            if status and trade.get("status") != status:
                continue
            if side and trade.get("side") != side:
                continue
            
            # Calculate trade value for cost analysis
            trade_copy = trade.copy()
            trade_copy["trade_value"] = float(trade.get("quantity", 0)) * float(trade.get("price", 0))
            results.append(trade_copy)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_fund_trade_details",
                "description": "Get fund trade details for transaction cost analysis",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "instrument_id": {"type": "string", "description": "Filter by instrument ID (optional)"},
                        "status": {"type": "string", "description": "Filter by trade status (approved, executed, pending, failed)"},
                        "side": {"type": "string", "description": "Filter by trade side (buy, sell)"}
                    },
                    "required": ["fund_id"]
                }
            }
        }


--------------------------------------
FILE: get_growth_rate.py
FULL PATH: ./interface_2/get_growth_rate.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class GetGrowthRate(Tool):
    # Growth rate mapping

    @staticmethod
    def invoke(data: Dict[str, Any], fund_type: str, instrument_type: str) -> str:
        """Return growth rate for a given fund type and instrument type."""
        FUND_GROWTH_RATES: Dict[str, Dict[str, str]] = {
            "mutual_funds": {
                "equities": "8%",
                "bonds": "3.50%",
                "money_market_instruments": "2%",
                "hybrid_securities": "5.50%",
                "fund_units": "6.50%"
            },
            "exchange_traded_funds": {
                "equities": "8%",
                "bonds": "3%",
                "commodities": "5%",
                "derivatives": "-20% to 20%"
            },
            "pension_funds": {
                "equities": "7%",
                "bonds": "3%",
                "real_estate": "6.50%",
                "private_equity": "16%",
                "financing_and_debt": "16%",
                "alternative_assets": "7.50%"
            },
            "private_equity_funds": {
                "private_equity": "20%",
                "financing_and_debt": "16% - 18.50%"  # grouped similar debt instruments
            },
            "hedge_funds": {
                "equities": "10%",
                "bonds": "8%",
                "derivatives": "-15% to 15%",
                "commodities": "2.50%",
                "structured_products": "8.50%"
            },
            "sovereign_wealth_funds": {
                "equities": "7%",
                "bonds": "3%",
                "private_equity": "16%",
                "real_estate": "6.50%",
                "financing_and_debt": "8%",
                "alternative_assets": "7.50%"
            },
            "money_market_funds": {
                "money_market_instruments": "1.50% - 2%"
            },
            "real_estate_investment_trusts": {
                "real_estate": "6.50% - 8%"
            },
            "infrastructure_funds": {
                "private_equity": "8%",
                "financing_and_debt": "6.50% - 8%"
            },
            "multi_asset_funds": {
                "equities": "8%",
                "bonds": "3.50%",
                "real_estate": "6.50%",
                "commodities": "5%"
            }
        }
        fund_data = FUND_GROWTH_RATES.get(fund_type.lower())
        if not fund_data:
            return json.dumps({"error": "Invalid fund type"})
        
        growth_rate = fund_data.get(instrument_type.lower())
        if not growth_rate:
            return json.dumps({"error": "Invalid instrument type for this fund"})
        
        return json.dumps({
            "fund_type": fund_type,
            "instrument_type": instrument_type,
            "growth_rate": growth_rate
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_growth_rate",
                "description": "Get expected growth rate for a given fund type and instrument type",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_type": {
                            "type": "string",
                            "description": (
                                "The fund type. "
                                "Valid values: mutual_funds, exchange_traded_funds, pension_funds, "
                                "private_equity_funds, hedge_funds, sovereign_wealth_funds, "
                                "money_market_funds, real_estate_investment_trusts, "
                                "infrastructure_funds, multi_asset_funds"
                            )
                        },
                        "instrument_type": {
                            "type": "string",
                            "description": (
                                "The instrument type. "
                                "Valid values: equities, bonds, money_market_instruments, hybrid_securities, fund_units, "
                                "commodities, derivatives, real_estate, private_equity, financing_and_debt, "
                                "alternative_assets, structured_products"
                            )
                        }
                    },
                    "required": ["fund_type", "instrument_type"]
                }
            }
        }



--------------------------------------
FILE: get_instruments.py
FULL PATH: ./interface_2/get_instruments.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInstruments(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_type: Optional[str] = None,
               status: Optional[str] = None, ticker: Optional[str] = None) -> str:
        instruments = data.get("instruments", {})
        results = []
        
        for instrument in instruments.values():
            if instrument_type and instrument.get("instrument_type") != instrument_type:
                continue
            if status and instrument.get("status") != status:
                continue
            if ticker and instrument.get("ticker") != ticker:
                continue
            results.append(instrument)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_instruments",
                "description": "Get instruments for investment universe management",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_type": {
                            "type": "string",
                            "description": "Filter by instrument type",
                            "enum": [
                                "equities",
                                "bonds",
                                "money_market_instruments",
                                "hybrid_securities",
                                "fund_units",
                                "commodities",
                                "derivatives",
                                "real_estate",
                                "private_equity",
                                "financing_and_debt",
                                "alternative_assets",
                                "structured_products"
                            ]
                        },
                        "status": {"type": "string", "description": "Filter by status (active, inactive)"},
                        "ticker": {"type": "string", "description": "Filter by ticker symbol"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: get_instruments_prices.py
FULL PATH: ./interface_2/get_instruments_prices.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInstrumentsPrices(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_id: Optional[str] = None,
               price_date: Optional[str] = None) -> str:
        instrument_prices = data.get("instrument_prices", {})
        instruments = data.get("instruments", {})
        results = []
        
        # Validate instrument if provided
        if instrument_id and str(instrument_id) not in instruments:
            raise ValueError(f"Instrument {instrument_id} not found")
        
        for price in instrument_prices.values():
            if instrument_id and price.get("instrument_id") != instrument_id:
                continue
            if price_date and price.get("price_date") != price_date:
                continue
            results.append(price)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_instruments_prices",
                "description": "Get instrument prices for pricing and valuation",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_id": {"type": "string", "description": "Filter by instrument ID (optional)"},
                        "price_date": {"type": "string", "description": "Filter by price date (optional)"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: get_notifications.py
FULL PATH: ./interface_2/get_notifications.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetNotifications(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], email: Optional[str] = None,
               notification_type: Optional[str] = None, status: Optional[str] = None,
               notification_class: Optional[str] = None) -> str:
        notifications = data.get("notifications", {})
        results = []
        
        for notification in notifications.values():
            if email and notification.get("email") != email:
                continue
            if notification_type and notification.get("type") != notification_type:
                continue
            if status and notification.get("status") != status:
                continue
            if notification_class and notification.get("class") != notification_class:
                continue
            results.append(notification)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_notifications",
                "description": "Get notifications for message management",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "email": {"type": "string", "description": "Filter by email address"},
                        "notification_type": {"type": "string", "description": "Filter by notification type (alert, report, reminder, subscription_update)"},
                        "status": {"type": "string", "description": "Filter by status (pending, sent, failed)"},
                        "notification_class": {"type": "string", "description": "Filter by notification class"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: get_reports.py
FULL PATH: ./interface_2/get_reports.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetReports(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: Optional[str] = None, 
               investor_id: Optional[str] = None, report_type: Optional[str] = None,
               status: Optional[str] = None) -> str:
        reports = data.get("reports", {})
        results = []
        
        for report in reports.values():
            if fund_id and report.get("fund_id") != fund_id:
                continue
            if investor_id and report.get("investor_id") != investor_id:
                continue
            if report_type and report.get("report_type") != report_type:
                continue
            if status and report.get("status") != status:
                continue
            results.append(report)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_reports",
                "description": "Get reports with optional filters for distribution and access",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "Filter by fund ID"},
                        "investor_id": {"type": "string", "description": "Filter by investor ID"},
                        "report_type": {"type": "string", "description": "Filter by report type (performance, holding, financial)"},
                        "status": {"type": "string", "description": "Filter by status (pending, completed, failed)"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: send_email_notification.py
FULL PATH: ./interface_2/send_email_notification.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class SendEmailNotification(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], email: str, notification_type: str, 
               notification_class: str, reference_id: Optional[str] = None) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        notifications = data.get("notifications", {})
        
        # Validate notification type
        valid_types = ["alert", "report", "reminder", "subscription_update"]
        if notification_type not in valid_types:
            raise ValueError(f"Invalid notification type. Must be one of {valid_types}")
        
        # Validate notification class
        valid_classes = ["funds", "investors", "portfolios", "trades", "invoices", 
                        "reports", "documents", "subscriptions", "commitments"]
        if notification_class not in valid_classes:
            raise ValueError(f"Invalid notification class. Must be one of {valid_classes}")
        
        notification_id = generate_id(notifications)
        timestamp = "2025-10-01T00:00:00"
        
        new_notification = {
            "notification_id": notification_id,
            "email": email,
            "type": notification_type,
            "class": notification_class,
            "reference_id": reference_id,
            "status": "pending",
            "sent_at": None,
            "created_at": timestamp
        }
        
        notifications[str(notification_id)] = new_notification
        return json.dumps({"notification_id": notification_id})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "send_email_notification",
                "description": "Send email notification for client communication",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "email": {"type": "string", "description": "Recipient email address"},
                        "notification_type": {"type": "string", "description": "Notification type (alert, report, reminder, subscription_update)"},
                        "notification_class": {"type": "string", "description": "Notification class (funds, investors, portfolios, trades, invoices, reports, documents, subscriptions, commitments)"},
                        "reference_id": {"type": "string", "description": "Reference ID for related entity (optional)"}
                    },
                    "required": ["email", "notification_type", "notification_class"]
                }
            }
        }


--------------------------------------
FILE: update_instrument_price.py
FULL PATH: ./interface_2/update_instrument_price.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class UpdateInstrumentPrice(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_id: str, price_date: str,
               open_price: Optional[float] = None, high_price: Optional[float] = None, 
               low_price: Optional[float] = None, close_price: Optional[float] = None) -> str:
        """
        Update daily price data for instruments. Only instrument_id and price_date are required,
        with at least one price attribute provided.
        
        Args:
            data: Main data dictionary containing instruments and instrument_prices
            instrument_id: ID of the instrument (required)
            price_date: Date of the price data (required)
            open_price: Opening price (optional)
            high_price: Highest price (optional)
            low_price: Lowest price (optional)
            close_price: Closing price (optional)
        
        Returns:
            JSON string indicating whether record was created or updated
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        instruments = data.get("instruments", {})
        instrument_prices = data.get("instrument_prices", {})
        
        # Validate instrument exists
        if str(instrument_id) not in instruments:
            raise ValueError(f"Instrument {instrument_id} not found")
        
        # Validate at least one price attribute is provided
        price_attributes = [open_price, high_price, low_price, close_price]
        if all(price is None for price in price_attributes):
            raise ValueError("At least one price attribute (open_price, high_price, low_price, close_price) must be provided")
        
        # Check if price record already exists for this instrument and date
        existing_price_id = None
        existing_record = None
        for price_id, price_record in instrument_prices.items():
            if (price_record.get("instrument_id") == instrument_id and 
                price_record.get("price_date") == price_date):
                existing_price_id = price_id
                existing_record = price_record.copy()
                break
        
        # Build price record
        if existing_record:
            # Update existing record with new values only where provided
            price_record = existing_record
            if open_price is not None:
                price_record["open_price"] = open_price
            if high_price is not None:
                price_record["high_price"] = high_price
            if low_price is not None:
                price_record["low_price"] = low_price
            if close_price is not None:
                price_record["close_price"] = close_price
        else:
            # Create new record with provided values
            price_record = {
                "instrument_id": instrument_id,
                "price_date": price_date
            }
            if open_price is not None:
                price_record["open_price"] = open_price
            if high_price is not None:
                price_record["high_price"] = high_price
            if low_price is not None:
                price_record["low_price"] = low_price
            if close_price is not None:
                price_record["close_price"] = close_price
        
        if existing_price_id:
            # Update existing record
            price_record["price_id"] = int(existing_price_id)
            instrument_prices[existing_price_id] = price_record
            return json.dumps({"instrument_price_update": instrument_prices[existing_price_id]})
        else:
            # Create new record
            price_id = generate_id(instrument_prices)
            price_record["price_id"] = price_id
            instrument_prices[str(price_id)] = price_record
            return json.dumps({"status": "created", "price_id": price_id})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_instrument_price",
                "description": "Update daily price data for instruments. Only instrument_id and price_date are required, with at least one price attribute provided.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_id": {"type": "string", "description": "ID of the instrument"},
                        "price_date": {"type": "string", "description": "Date of the price data (format: YYYY-MM-DD)"},
                        "open_price": {"type": "number", "description": "Opening price (optional)"},
                        "high_price": {"type": "number", "description": "Highest price (optional)"},
                        "low_price": {"type": "number", "description": "Lowest price (optional)"},
                        "close_price": {"type": "number", "description": "Closing price (optional)"}
                    },
                    "required": ["instrument_id", "price_date"]
                }
            }
        }

--------------------------------------
FILE: update_trade.py
FULL PATH: ./interface_2/update_trade.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class UpdateTrade(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], trade_id: str, status: Optional[str] = None,
               quantity: Optional[float] = None, price: Optional[float] = None) -> str:
        trades = data.get("trades", {})
        
        # Validate trade exists
        if str(trade_id) not in trades:
            raise ValueError(f"Trade {trade_id} not found")
        
        trade = trades[str(trade_id)]
        
        # Validate status if provided
        if status:
            valid_statuses = ["approved", "executed", "pending", "failed"]
            if status not in valid_statuses:
                raise ValueError(f"Invalid status. Must be one of {valid_statuses}")
            trade["status"] = status
        
        # Update other fields if provided
        if quantity is not None:
            trade["quantity"] = quantity
        
        if price is not None:
            trade["price"] = price
        
        trade["updated_at"] = "2025-10-01T00:00:00"
        
        return json.dumps(trade)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_trade",
                "description": "Update trade for settlement and corrections",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "trade_id": {"type": "string", "description": "ID of the trade to update"},
                        "status": {"type": "string", "description": "New status (approved, executed, pending, failed)"},
                        "quantity": {"type": "number", "description": "Updated quantity"},
                        "price": {"type": "number", "description": "Updated price"}
                    },
                    "required": ["trade_id"]
                }
            }
        }



======================================
DIRECTORY: ./interface_3
======================================

--------------------------------------
FILE: get_available_funds.py
FULL PATH: ./interface_3/get_available_funds.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetAvailableFunds(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: Optional[str] = None, investor_id: Optional[str] = None, 
               fund_type: Optional[str] = None, status: Optional[str] = None) -> str:
        """
        Get available funds for investment based on filters.
        
        Args:
            data: Main data dictionary containing funds and investors
            investor_id: Optional investor ID for validation
            fund_type: Optional fund type filter. Valid types:
                - mutual_funds
                - exchange_traded_funds
                - pension_funds
                - private_equity_funds
                - hedge_funds
                - sovereign_wealth_funds
                - money_market_funds
                - real_estate_investment_trusts
                - infrastructure_funds
                - multi_asset_funds
            status: Optional status filter (open, closed)
        
        Returns:
            JSON string of matching fund objects
        """
        funds = data.get("funds", {})
        investors = data.get("investors", {})
        results = []
        
        # Valid fund types from database schema
        valid_fund_types = {
            'mutual_funds',
            'exchange_traded_funds',
            'pension_funds',
            'private_equity_funds',
            'hedge_funds',
            'sovereign_wealth_funds',
            'money_market_funds',
            'real_estate_investment_trusts',
            'infrastructure_funds',
            'multi_asset_funds'
        }
        
        # Valid statuses from database schema
        valid_statuses = {'open', 'closed'}
        
        # Validate fund_type if provided
        if fund_type and fund_type not in valid_fund_types:
            raise ValueError(f"Invalid fund_type '{fund_type}'. Valid types are: {', '.join(sorted(valid_fund_types))}")
        
        # Validate status if provided
        if status and status not in valid_statuses:
            raise ValueError(f"Invalid status '{status}'. Valid statuses are: {', '.join(sorted(valid_statuses))}")
        
        # If investor_id is provided, validate it exists
        if investor_id and str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        if fund_id:
            fund = funds.get(fund_id)
            if not fund:
                raise ValueError(f"Fund {fund_id} not found")
            # If a specific fund is requested, filter by it
            funds = {fund_id: fund}

        for fund in funds.values():
            # Filter by fund type if specified
            if fund_type and fund.get("fund_type") != fund_type:
                continue
            
            # Filter by status if specified (default to "open" if not specified)
            if status and fund.get("status") != status:
                continue
            elif not status and fund.get("status") != "open":
                continue
            
            results.append(fund)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_available_funds",
                "description": "List all funds available for investment based on investor's accreditation and eligibility",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {
                            "type": "string",
                            "description": "ID of the fund (optional)"
                        },
                        "investor_id": {
                            "type": "string", 
                            "description": "ID of the investor (optional)"
                        },
                        "fund_type": {
                            "type": "string", 
                            "description": "Filter by fund type",
                            "enum": [
                                "mutual_funds",
                                "exchange_traded_funds", 
                                "pension_funds",
                                "private_equity_funds",
                                "hedge_funds",
                                "sovereign_wealth_funds",
                                "money_market_funds",
                                "real_estate_investment_trusts",
                                "infrastructure_funds",
                                "multi_asset_funds"
                            ]
                        },
                        "status": {
                            "type": "string", 
                            "description": "Filter by fund status",
                            "enum": ["open", "closed"]
                        }
                    },
                    "required": []
                }
            }
        }

--------------------------------------
FILE: get_fund_nav_history.py
FULL PATH: ./interface_3/get_fund_nav_history.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetFundNavHistory(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, 
               start_date: Optional[str] = None, end_date: Optional[str] = None) -> str:
        funds = data.get("funds", {})
        nav_records = data.get("nav_records", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            raise ValueError(f"Fund {fund_id} not found")
        
        # Get NAV records for this fund
        fund_navs = []
        for nav in nav_records.values():
            if nav.get("fund_id") == fund_id:
                nav_date = nav.get("nav_date")
                
                # Filter by date range if provided
                if start_date and nav_date < start_date:
                    continue
                if end_date and nav_date > end_date:
                    continue
                
                fund_navs.append(nav)
        
        # Sort by date
        fund_navs.sort(key=lambda x: x.get("nav_date", ""))
        
        return json.dumps(fund_navs)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_fund_nav_history",
                "description": "Retrieve historical Net Asset Value data for specific funds over time periods",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "start_date": {"type": "string", "description": "Start date for NAV history (YYYY-MM-DD format)"},
                        "end_date": {"type": "string", "description": "End date for NAV history (YYYY-MM-DD format)"}
                    },
                    "required": ["fund_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_commitments.py
FULL PATH: ./interface_3/get_investor_commitments.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorCommitments(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, 
               status: Optional[str] = None, fund_id: Optional[str] = None) -> str:
        investors = data.get("investors", {})
        commitments = data.get("commitments", {})
        funds = data.get("funds", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        # Get commitments for this investor
        investor_commitments = []
        for commitment in commitments.values():
            if commitment.get("investor_id") == investor_id:
                # Filter by status if specified
                if status and commitment.get("status") != status:
                    continue
                
                # Filter by fund if specified
                if fund_id and commitment.get("fund_id") != fund_id:
                    continue
                
                # Enrich with fund details
                comm_fund_id = commitment.get("fund_id")
                fund_details = funds.get(str(comm_fund_id), {})
                
                enriched_commitment = {
                    **commitment,
                    "fund_name": fund_details.get("name"),
                    "fund_type": fund_details.get("fund_type")
                }
                investor_commitments.append(enriched_commitment)
        
        return json.dumps(investor_commitments)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_commitments",
                "description": "Retrieve all capital commitments and their fulfillment status",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "status": {"type": "string", "description": "Filter by commitment status (pending, fulfilled)"},
                        "fund_id": {"type": "string", "description": "Filter by fund ID"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_documents.py
FULL PATH: ./interface_3/get_investor_documents.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorDocuments(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, 
               document_format: Optional[str] = None, confidentiality_level: Optional[str] = None,
               status: Optional[str] = None) -> str:
        investors = data.get("investors", {})
        documents = data.get("documents", {})
        reports = data.get("reports", {})
        users = data.get("users", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        # Get documents related to this investor through reports
        investor_documents = []
        
        # First, find all reports for this investor
        investor_report_ids = []
        for report in reports.values():
            if report.get("investor_id") == investor_id:
                investor_report_ids.append(report.get("report_id"))
        
        # Then find documents associated with these reports
        for document in documents.values():
            report_id = document.get("report_id")
            
            # Include document if it's associated with investor's reports or if no report_id (general docs)
            if report_id in investor_report_ids or not report_id:
                # Filter by format if specified
                if document_format and document.get("format") != document_format:
                    continue
                
                # Filter by confidentiality level if specified
                if confidentiality_level and document.get("confidentiality_level") != confidentiality_level:
                    continue
                
                # Filter by status if specified
                if status and document.get("status") != status:
                    continue
                
                # Enrich with uploader details
                uploaded_by = document.get("uploaded_by")
                uploader = users.get(str(uploaded_by), {})
                
                enriched_document = {
                    **document,
                    "uploader_name": f"{uploader.get('first_name', '')} {uploader.get('last_name', '')}".strip(),
                    "uploader_email": uploader.get("email")
                }
                investor_documents.append(enriched_document)
        
        return json.dumps(investor_documents)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_documents",
                "description": "Retrieve all documents related to the investor (agreements, reports, correspondence)",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "document_format": {"type": "string", "description": "Filter by document format (pdf, xlsx, docx, csv, other)"},
                        "confidentiality_level": {"type": "string", "description": "Filter by confidentiality level (public, internal, confidential, restricted)"},
                        "status": {"type": "string", "description": "Filter by document status (available, archived, deleted)"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_portfolio.py
FULL PATH: ./interface_3/get_investor_portfolio.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorPortfolio(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str) -> str:
        investors = data.get("investors", {})
        portfolios = data.get("portfolios", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        # Find investor's portfolio
        investor_portfolio = None
        for portfolio in portfolios.values():
            if portfolio.get("investor_id") == investor_id:
                investor_portfolio = portfolio
                break
        
        if not investor_portfolio:
            return json.dumps({"message": "No portfolio found for investor"})
        
        return json.dumps(investor_portfolio)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_portfolio",
                "description": "Get the investor's complete portfolio overview including all holdings and performance metrics",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_portfolio_holdings.py
FULL PATH: ./interface_3/get_investor_portfolio_holdings.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorPortfolioHoldings(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str) -> str:
        investors = data.get("investors", {})
        portfolios = data.get("portfolios", {})
        portfolio_holdings = data.get("portfolio_holdings", {})
        funds = data.get("funds", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        # Find investor's portfolio
        investor_portfolio = None
        for portfolio in portfolios.values():
            if portfolio.get("investor_id") == investor_id:
                investor_portfolio = portfolio
                break
        
        if not investor_portfolio:
            return json.dumps([])
        
        # Get holdings for this portfolio
        holdings = []
        for holding in portfolio_holdings.values():
            if holding.get("portfolio_id") == investor_portfolio.get("portfolio_id"):
                # Enrich with fund details
                fund_id = holding.get("fund_id")
                fund_details = funds.get(str(fund_id), {})
                
                enriched_holding = {
                    **holding,
                    "fund_name": fund_details.get("name"),
                    "fund_type": fund_details.get("fund_type"),
                    "fund_status": fund_details.get("status")
                }
                holdings.append(enriched_holding)
        
        return json.dumps(holdings)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_portfolio_holdings",
                "description": "Retrieve detailed breakdown of all fund holdings within the investor's portfolio",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_profile.py
FULL PATH: ./interface_3/get_investor_profile.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorProfile(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str) -> str:
        investors = data.get("investors", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        investor = investors[str(investor_id)]
        return json.dumps(investor)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_profile",
                "description": "Retrieve complete investor profile information including KYC details, status, and contact information",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_redemptions.py
FULL PATH: ./interface_3/get_investor_redemptions.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorRedemptions(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, 
               status: Optional[str] = None) -> str:
        investors = data.get("investors", {})
        redemptions = data.get("redemptions", {})
        subscriptions = data.get("subscriptions", {})
        funds = data.get("funds", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        # Get redemptions for this investor
        investor_redemptions = []
        for redemption in redemptions.values():
            # Find the subscription this redemption relates to
            subscription_id = redemption.get("subscription_id")
            subscription = subscriptions.get(str(subscription_id), {})
            
            # Check if this subscription belongs to our investor
            if subscription.get("investor_id") == investor_id:
                # Filter by status if specified
                if status and redemption.get("status") != status:
                    continue
                
                # Enrich with fund details
                fund_id = subscription.get("fund_id")
                fund_details = funds.get(str(fund_id), {})
                
                enriched_redemption = {
                    **redemption,
                    "fund_id": fund_id,
                    "fund_name": fund_details.get("name"),
                    "fund_type": fund_details.get("fund_type"),
                    "original_subscription_amount": subscription.get("amount")
                }
                investor_redemptions.append(enriched_redemption)
        
        return json.dumps(investor_redemptions)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_redemptions",
                "description": "View all redemption requests including pending, approved, and processed transactions",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "status": {"type": "string", "description": "Filter by redemption status (pending, approved, processed, cancelled)"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_statements.py
FULL PATH: ./interface_3/get_investor_statements.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorStatements(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, 
               report_type: Optional[str] = None, start_date: Optional[str] = None, 
               end_date: Optional[str] = None) -> str:
        investors = data.get("investors", {})
        reports = data.get("reports", {})
        documents = data.get("documents", {})
        users = data.get("users", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        # Get reports for this investor
        investor_statements = []
        for report in reports.values():
            if report.get("investor_id") == investor_id:
                # Filter by report type if specified
                if report_type and report.get("report_type") != report_type:
                    continue
                
                # Filter by date range if provided
                report_date = report.get("report_date")
                if start_date and report_date < start_date:
                    continue
                if end_date and report_date > end_date:
                    continue
                
                # Enrich with generator details
                generated_by = report.get("generated_by")
                generator = users.get(str(generated_by), {})
                
                # Find associated documents
                report_id = report.get("report_id")
                associated_docs = []
                for doc in documents.values():
                    if doc.get("report_id") == report_id:
                        associated_docs.append({
                            "document_id": doc.get("document_id"),
                            "name": doc.get("name"),
                            "format": doc.get("format"),
                            "size_bytes": doc.get("size_bytes"),
                            "upload_date": doc.get("upload_date")
                        })
                
                enriched_report = {
                    **report,
                    "generator_name": f"{generator.get('first_name', '')} {generator.get('last_name', '')}".strip(),
                    "documents": associated_docs
                }
                investor_statements.append(enriched_report)
        
        return json.dumps(investor_statements)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_statements",
                "description": "Access periodic statements including performance, holdings, and transaction summaries",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "report_type": {"type": "string", "description": "Filter by report type (performance, holding, financial)"},
                        "start_date": {"type": "string", "description": "Start date for reports (YYYY-MM-DD format)"},
                        "end_date": {"type": "string", "description": "End date for reports (YYYY-MM-DD format)"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_subscriptions.py
FULL PATH: ./interface_3/get_investor_subscriptions.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorSubscriptions(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, 
               status: Optional[str] = None, fund_id: Optional[str] = None) -> str:
        investors = data.get("investors", {})
        subscriptions = data.get("subscriptions", {})
        funds = data.get("funds", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        # Get subscriptions for this investor
        investor_subscriptions = []
        for subscription in subscriptions.values():
            if subscription.get("investor_id") == investor_id:
                # Filter by status if specified
                if status and subscription.get("status") != status:
                    continue
                
                # Filter by fund if specified
                if fund_id and subscription.get("fund_id") != fund_id:
                    continue
                
                # Enrich with fund details
                sub_fund_id = subscription.get("fund_id")
                fund_details = funds.get(str(sub_fund_id), {})
                
                enriched_subscription = {
                    **subscription,
                    "fund_name": fund_details.get("name"),
                    "fund_type": fund_details.get("fund_type")
                }
                investor_subscriptions.append(enriched_subscription)
        
        return json.dumps(investor_subscriptions)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_subscriptions",
                "description": "List all subscription requests and their current status (pending, approved, cancelled)",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "status": {"type": "string", "description": "Filter by subscription status (pending, approved, cancelled)"},
                        "fund_id": {"type": "string", "description": "Filter by fund ID"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_investor_transactions_history.py
FULL PATH: ./interface_3/get_investor_transactions_history.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvestorTransactionsHistory(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, 
               start_date: Optional[str] = None, end_date: Optional[str] = None,
               transaction_type: Optional[str] = None) -> str:
        investors = data.get("investors", {})
        subscriptions = data.get("subscriptions", {})
        redemptions = data.get("redemptions", {})
        payments = data.get("payments", {})
        commitments = data.get("commitments", {})
        funds = data.get("funds", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        transactions = []
        
        # Get subscriptions
        if not transaction_type or transaction_type == "subscription":
            for subscription in subscriptions.values():
                if subscription.get("investor_id") == investor_id:
                    request_date = subscription.get("request_date")
                    
                    # Date filtering
                    if start_date and request_date < start_date:
                        continue
                    if end_date and request_date > end_date:
                        continue
                    
                    # Enrich with fund details
                    fund_id = subscription.get("fund_id")
                    fund_details = funds.get(str(fund_id), {})
                    
                    transactions.append({
                        "transaction_id": subscription.get("subscription_id"),
                        "transaction_type": "subscription",
                        "fund_id": fund_id,
                        "fund_name": fund_details.get("name"),
                        "amount": subscription.get("amount"),
                        "status": subscription.get("status"),
                        "date": request_date,
                        "approval_date": subscription.get("approval_date")
                    })
        
        # Get redemptions
        if not transaction_type or transaction_type == "redemption":
            for redemption in redemptions.values():
                subscription_id = redemption.get("subscription_id")
                subscription = subscriptions.get(str(subscription_id), {})
                
                if subscription.get("investor_id") == investor_id:
                    request_date = redemption.get("request_date")
                    
                    # Date filtering
                    if start_date and request_date < start_date:
                        continue
                    if end_date and request_date > end_date:
                        continue
                    
                    # Enrich with fund details
                    fund_id = subscription.get("fund_id")
                    fund_details = funds.get(str(fund_id), {})
                    
                    transactions.append({
                        "transaction_id": redemption.get("redemption_id"),
                        "transaction_type": "redemption",
                        "fund_id": fund_id,
                        "fund_name": fund_details.get("name"),
                        "amount": redemption.get("redemption_amount"),
                        "status": redemption.get("status"),
                        "date": request_date,
                        "processed_date": redemption.get("processed_date"),
                        "redemption_fee": redemption.get("redemption_fee")
                    })
        
        # Get commitments
        if not transaction_type or transaction_type == "commitment":
            for commitment in commitments.values():
                if commitment.get("investor_id") == investor_id:
                    commitment_date = commitment.get("commitment_date")
                    
                    # Date filtering
                    if start_date and commitment_date < start_date:
                        continue
                    if end_date and commitment_date > end_date:
                        continue
                    
                    # Enrich with fund details
                    fund_id = commitment.get("fund_id")
                    fund_details = funds.get(str(fund_id), {})
                    
                    transactions.append({
                        "transaction_id": commitment.get("commitment_id"),
                        "transaction_type": "commitment",
                        "fund_id": fund_id,
                        "fund_name": fund_details.get("name"),
                        "amount": commitment.get("commitment_amount"),
                        "status": commitment.get("status"),
                        "date": commitment_date
                    })
        
        # Sort by date (most recent first)
        transactions.sort(key=lambda x: x.get("date", ""), reverse=True)
        
        return json.dumps(transactions)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_transactions_history",
                "description": "Comprehensive transaction history including all subscriptions, redemptions, switches, and payments",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "start_date": {"type": "string", "description": "Start date for transaction history (YYYY-MM-DD format)"},
                        "end_date": {"type": "string", "description": "End date for transaction history (YYYY-MM-DD format)"},
                        "transaction_type": {"type": "string", "description": "Filter by transaction type (subscription, redemption, commitment)"}
                    },
                    "required": ["investor_id"]
                }
            }
        }



======================================
DIRECTORY: ./interface_4
======================================

--------------------------------------
FILE: add_new_holding.py
FULL PATH: ./interface_4/add_new_holding.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class AddNewHolding(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], portfolio_id: str, fund_id: str,
               quantity: float, cost_basis: float) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        portfolio_holdings = data.get("portfolio_holdings", {})
        portfolios = data.get("portfolios", {})
        funds = data.get("funds", {})
        
        # Validate portfolio exists
        if str(portfolio_id) not in portfolios:
            raise ValueError(f"Portfolio {portfolio_id} not found")
        
        # Validate fund exists
        if str(fund_id) not in funds:
            raise ValueError(f"Fund {fund_id} not found")
        
        holding_id = generate_id(portfolio_holdings)
        timestamp = "2025-10-01T00:00:00"
        
        new_holding = {
            "holding_id": str(holding_id),
            "portfolio_id": str(portfolio_id),
            "fund_id": str(fund_id),
            "quantity": quantity,
            "cost_basis": cost_basis,
            "created_at": timestamp
        }
        
        portfolio_holdings[str(holding_id)] = new_holding
        return json.dumps(new_holding)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "add_new_holding",
                "description": "Add new holding for investment execution",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "portfolio_id": {"type": "string", "description": "ID of the portfolio"},
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "quantity": {"type": "number", "description": "Quantity of holding"},
                        "cost_basis": {"type": "number", "description": "Cost basis of holding"}
                    },
                    "required": ["portfolio_id", "fund_id", "quantity", "cost_basis"]
                }
            }
        }


--------------------------------------
FILE: get_filtered_investors.py
FULL PATH: ./interface_4/get_filtered_investors.py
--------------------------------------

import json
from typing import Any, Dict, Optional, List
from datetime import datetime
from tau_bench.envs.tool import Tool

class GetFilteredInvestors(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], 
               accreditation_status: Optional[str] = None,
               status: Optional[str] = None, 
               country: Optional[str] = None,
               source_of_funds: Optional[str] = None,
               name_contains: Optional[str] = None,
               registration_number: Optional[int] = None,
               incorporation_date_from: Optional[str] = None,
               incorporation_date_to: Optional[str] = None,
               countries: Optional[List[str]] = None,
               has_tax_id: Optional[bool] = None,
               has_registration_number: Optional[bool] = None,
               created_after: Optional[str] = None,
               created_before: Optional[str] = None,
               email_domain: Optional[str] = None,
               address_contains: Optional[str] = None) -> str:
        
        investors = data.get("investors", {})
        results = []
        
        for investor in investors.values():
            # Existing filters
            if accreditation_status and investor.get("accreditation_status") != accreditation_status:
                continue
            if status and investor.get("status") != status:
                continue
            if country and investor.get("country") != country:
                continue
            if source_of_funds and investor.get("source_of_funds") != source_of_funds:
                continue
            
            # New name filter
            if name_contains and name_contains.lower() not in investor.get("name", "").lower():
                continue
            
            # Registration number filter
            if registration_number and investor.get("registration_number") != registration_number:
                continue
            
            # Date of incorporation filters
            if incorporation_date_from or incorporation_date_to:
                inc_date = investor.get("date_of_incorporation")
                if inc_date:
                    try:
                        inc_date_obj = datetime.strptime(inc_date, "%Y-%m-%d").date()
                        if incorporation_date_from:
                            from_date = datetime.strptime(incorporation_date_from, "%Y-%m-%d").date()
                            if inc_date_obj < from_date:
                                continue
                        if incorporation_date_to:
                            to_date = datetime.strptime(incorporation_date_to, "%Y-%m-%d").date()
                            if inc_date_obj > to_date:
                                continue
                    except (ValueError, TypeError):
                        if incorporation_date_from or incorporation_date_to:
                            continue
                elif incorporation_date_from or incorporation_date_to:
                    continue
            
            # Multiple countries filter
            if countries and investor.get("country") not in countries:
                continue
            
            # Tax ID presence filter
            if has_tax_id is not None:
                tax_id = investor.get("tax_id")
                if has_tax_id and (not tax_id or tax_id.strip() == ""):
                    continue
                if not has_tax_id and tax_id and tax_id.strip() != "":
                    continue
            
            # Registration number presence filter
            if has_registration_number is not None:
                reg_num = investor.get("registration_number")
                if has_registration_number and reg_num is None:
                    continue
                if not has_registration_number and reg_num is not None:
                    continue
            
            # Created date filters
            if created_after or created_before:
                created_at = investor.get("created_at")
                if created_at:
                    try:
                        created_date = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                        if created_after:
                            after_date = datetime.fromisoformat(created_after.replace('Z', '+00:00'))
                            if created_date < after_date:
                                continue
                        if created_before:
                            before_date = datetime.fromisoformat(created_before.replace('Z', '+00:00'))
                            if created_date > before_date:
                                continue
                    except (ValueError, TypeError):
                        if created_after or created_before:
                            continue
                elif created_after or created_before:
                    continue
            
            # Email domain filter
            if email_domain:
                email = investor.get("contact_email", "")
                if not email or not email.endswith(f"@{email_domain}"):
                    continue
            
            # Address contains filter
            if address_contains:
                address = investor.get("address", "")
                if address_contains.lower() not in address.lower():
                    continue
            
            results.append(investor)
        
        return json.dumps(results, indent=2)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_filtered_investors",
                "description": "Get filtered investors for CRM and marketing segmentation with comprehensive filtering options",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "accreditation_status": {
                            "type": "string", 
                            "description": "Filter by accreditation status (accredited/non_accredited)",
                            "enum": ["accredited", "non_accredited"]
                        },
                        "status": {
                            "type": "string", 
                            "description": "Filter by investor status (onboarded/offboarded)",
                            "enum": ["onboarded", "offboarded"]
                        },
                        "country": {
                            "type": "string", 
                            "description": "Filter by specific country"
                        },
                        "source_of_funds": {
                            "type": "string", 
                            "description": "Filter by specific source of funds",
                            "enum": ["retained_earnings", "shareholder_capital", "asset_sale", "loan_facility", 
                                   "external_investment", "government_grant", "merger_or_acquisition_proceeds", 
                                   "royalty_or_licensing_income", "dividend_income", "other"]
                        },
                        "name_contains": {
                            "type": "string", 
                            "description": "Filter by partial name match (case-insensitive)"
                        },
                        "registration_number": {
                            "type": "integer", 
                            "description": "Filter by specific registration number"
                        },
                        "incorporation_date_from": {
                            "type": "string", 
                            "description": "Filter investors incorporated on or after this date (YYYY-MM-DD format)"
                        },
                        "incorporation_date_to": {
                            "type": "string", 
                            "description": "Filter investors incorporated on or before this date (YYYY-MM-DD format)"
                        },
                        "countries": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Filter by multiple countries (returns investors from any of these countries)"
                        },
                        "has_tax_id": {
                            "type": "boolean", 
                            "description": "Filter by presence of tax ID (true for investors with tax ID, false for those without)"
                        },
                        "has_registration_number": {
                            "type": "boolean", 
                            "description": "Filter by presence of registration number (true for investors with reg number, false for those without)"
                        },
                        "created_after": {
                            "type": "string", 
                            "description": "Filter investors created after this timestamp (ISO format) [ex: 2022-08-17T04:30:00]"
                        },
                        "created_before": {
                            "type": "string", 
                            "description": "Filter investors created before this timestamp (ISO format) [ex: 2022-08-17T04:30:00]"
                        },
                        "email_domain": {
                            "type": "string", 
                            "description": "Filter by email domain (e.g., 'company.com' to find all @company.com emails)"
                        },
                        "address_contains": {
                            "type": "string", 
                            "description": "Filter by partial address match (case-insensitive)"
                        }
                    },
                    "required": []
                }
            }
        }

--------------------------------------
FILE: get_investor_portfolio.py
FULL PATH: ./interface_4/get_investor_portfolio.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class GetInvestorPortfolio(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str) -> str:
        portfolios = data.get("portfolios", {})
        results = []
        
        for portfolio in portfolios.values():
            if portfolio.get("investor_id") == str(investor_id):
                results.append(portfolio)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_investor_portfolio",
                "description": "Get investor portfolio for client servicing and performance tracking",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: get_portfolio_holdings.py
FULL PATH: ./interface_4/get_portfolio_holdings.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class GetPortfolioHoldings(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], portfolio_id: str) -> str:
        portfolio_holdings = data.get("portfolio_holdings", {})
        results = []
        
        for holding in portfolio_holdings.values():
            if holding.get("portfolio_id") == str(portfolio_id):
                results.append(holding)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_portfolio_holdings",
                "description": "Get portfolio holdings for holdings analysis and risk management",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "portfolio_id": {"type": "string", "description": "ID of the portfolio"}
                    },
                    "required": ["portfolio_id"]
                }
            }
        }


--------------------------------------
FILE: list_funds_with_filter.py
FULL PATH: ./interface_4/list_funds_with_filter.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ListFundsWithFilter(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_type: Optional[str] = None,
               manager_id: Optional[str] = None, status: Optional[str] = None,
               min_size: Optional[float] = None, max_size: Optional[float] = None) -> str:
        
        funds = data.get("funds", {})
        results = []
        
        for fund in funds.values():
            if fund_type and fund.get("fund_type") != fund_type:
                continue
            if manager_id and fund.get("manager_id") != str(manager_id):
                continue
            if status and fund.get("status") != status:
                continue
            if min_size is not None and (fund.get("size") is None or fund.get("size") < min_size):
                continue
            if max_size is not None and (fund.get("size") is None or fund.get("size") > max_size):
                continue
            results.append(fund)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "list_funds_with_filter",
                "description": "List funds with filters for investment screening and selection",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_type": {"type": "string", "description": "Filter by fund type"},
                        "manager_id": {"type": "string", "description": "Filter by manager ID"},
                        "status": {"type": "string", "description": "Filter by status"},
                        "min_size": {"type": "number", "description": "Minimum fund size"},
                        "max_size": {"type": "number", "description": "Maximum fund size"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: update_investor_details.py
FULL PATH: ./interface_4/update_investor_details.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class UpdateInvestorDetails(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, name: Optional[str] = None,
               contact_email: Optional[str] = None, accreditation_status: Optional[str] = None,
               registration_number: Optional[int] = None, date_of_incorporation: Optional[str] = None,
               country: Optional[str] = None, address: Optional[str] = None,
               tax_id: Optional[str] = None, source_of_funds: Optional[str] = None,
               status: Optional[str] = None) -> str:
        
        investors = data.get("investors", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            raise ValueError(f"Investor {investor_id} not found")
        
        investor = investors[str(investor_id)]
        
        # Validate accreditation status if provided
        if accreditation_status:
            valid_accreditation = ["accredited", "non_accredited"]
            if accreditation_status not in valid_accreditation:
                raise ValueError(f"Invalid accreditation status. Must be one of {valid_accreditation}")
            investor["accreditation_status"] = accreditation_status
        
        # Validate status if provided
        if status:
            valid_statuses = ["onboarded", "offboarded"]
            if status not in valid_statuses:
                raise ValueError(f"Invalid status. Must be one of {valid_statuses}")
            investor["status"] = status
        
        # Validate source of funds if provided
        if source_of_funds:
            valid_sources = ["retained_earnings", "shareholder_capital", "asset_sale", "loan_facility", 
                            "external_investment", "government_grant", "merger_or_acquisition_proceeds",
                            "royalty_or_licensing_income", "dividend_income", "other"]
            if source_of_funds not in valid_sources:
                raise ValueError(f"Invalid source of funds. Must be one of {valid_sources}")
            investor["source_of_funds"] = source_of_funds
        
        # Update fields if provided
        if name is not None:
            investor["name"] = name
        if contact_email is not None:
            investor["contact_email"] = contact_email
        if registration_number is not None:
            investor["registration_number"] = registration_number
        if date_of_incorporation is not None:
            investor["date_of_incorporation"] = date_of_incorporation
        if country is not None:
            investor["country"] = country
        if address is not None:
            investor["address"] = address
        if tax_id is not None:
            investor["tax_id"] = tax_id
        
        return json.dumps(investor)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_investor_details",
                "description": "Update investor details for regulatory updates and address changes",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "name": {"type": "string", "description": "Investor name (optional)"},
                        "contact_email": {"type": "string", "description": "Contact email address (optional)"},
                        "accreditation_status": {"type": "string", "description": "Accreditation status (optional)"},
                        "registration_number": {"type": "integer", "description": "Registration number (optional)"},
                        "date_of_incorporation": {"type": "string", "description": "Date of incorporation (optional)"},
                        "country": {"type": "string", "description": "Country (optional)"},
                        "address": {"type": "string", "description": "Address (optional)"},
                        "tax_id": {"type": "string", "description": "Tax ID (optional)"},
                        "source_of_funds": {"type": "string", "description": "Source of funds (optional)"},
                        "status": {"type": "string", "description": "Status (optional)"}
                    },
                    "required": ["investor_id"]
                }
            }
        }


--------------------------------------
FILE: update_investor_portfolio_holding.py
FULL PATH: ./interface_4/update_investor_portfolio_holding.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class UpdateInvestorPortfolioHolding(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], holding_id: str, quantity: Optional[float] = None,
               cost_basis: Optional[float] = None) -> str:
        
        portfolio_holdings = data.get("portfolio_holdings", {})
        
        # Validate holding exists
        if str(holding_id) not in portfolio_holdings:
            raise ValueError(f"Holding {holding_id} not found")
        
        holding = portfolio_holdings[str(holding_id)]
        
        # Update fields if provided
        if quantity is not None:
            holding["quantity"] = quantity
        if cost_basis is not None:
            holding["cost_basis"] = cost_basis
        
        return json.dumps(holding)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_investor_portfolio_holding",
                "description": "Update investor portfolio holding for position adjustments",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "holding_id": {"type": "string", "description": "ID of the holding"},
                        "quantity": {"type": "number", "description": "New quantity (optional)"},
                        "cost_basis": {"type": "number", "description": "New cost basis (optional)"}
                    },
                    "required": ["holding_id"]
                }
            }
        }



======================================
DIRECTORY: ./interface_5
======================================

--------------------------------------
FILE: create_invoice.py
FULL PATH: ./interface_5/create_invoice.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class CreateInvoice(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], commitment_id: str, invoice_date: str,
               due_date: str, amount: float, status: str = "issued") -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        commitments = data.get("commitments", {})
        invoices = data.get("invoices", {})
        
        # Validate commitment exists
        if str(commitment_id) not in commitments:
            raise ValueError(f"Commitment {commitment_id} not found")
        
        # Validate status
        valid_statuses = ["issued", "paid"]
        if status not in valid_statuses:
            raise ValueError(f"Invalid status. Must be one of {valid_statuses}")
        
        # Validate amount is positive
        if amount <= 0:
            raise ValueError("Amount must be positive")
        
        invoice_id = generate_id(invoices)
        timestamp = "2025-10-01T00:00:00"
        
        new_invoice = {
            "invoice_id": str(invoice_id),
            "commitment_id": commitment_id,
            "invoice_date": invoice_date,
            "due_date": due_date,
            "amount": amount,
            "status": status,
            "updated_at": timestamp
        }
        
        invoices[str(invoice_id)] = new_invoice
        return json.dumps(new_invoice)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_invoice",
                "description": "Create a new invoice for a commitment",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "commitment_id": {"type": "string", "description": "ID of the commitment"},
                        "invoice_date": {"type": "string", "description": "Invoice date in YYYY-MM-DD format"},
                        "due_date": {"type": "string", "description": "Due date in YYYY-MM-DD format"},
                        "amount": {"type": "number", "description": "Invoice amount"},
                        "status": {"type": "string", "description": "Invoice status (issued, paid), defaults to issued"}
                    },
                    "required": ["commitment_id", "invoice_date", "due_date", "amount"]
                }
            }
        }


--------------------------------------
FILE: delete_invoice.py
FULL PATH: ./interface_5/delete_invoice.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class DeleteInvoice(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], invoice_id: str) -> str:
        invoices = data.get("invoices", {})
        payments = data.get("payments", {})
        
        # Validate invoice exists
        if str(invoice_id) not in invoices:
            raise ValueError(f"Invoice {invoice_id} not found")
        
        # Check if invoice has associated payments
        for payment in payments.values():
            if payment.get("invoice_id") == invoice_id:
                raise ValueError(f"Cannot delete invoice {invoice_id} - it has associated payments")
        
        # Delete the invoice
        deleted_invoice = invoices.pop(str(invoice_id))
        
        return json.dumps({
            "status": "deleted",
            "deleted_invoice": deleted_invoice
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "delete_invoice",
                "description": "Delete an invoice (only if no payments are associated)",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "invoice_id": {"type": "string", "description": "ID of the invoice to delete"}
                    },
                    "required": ["invoice_id"]
                }
            }
        }


--------------------------------------
FILE: get_commitments.py
FULL PATH: ./interface_5/get_commitments.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetCommitments(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: Optional[str] = None,
               investor_id: Optional[str] = None, status: Optional[str] = None) -> str:
        commitments = data.get("commitments", {})
        results = []
        
        for commitment in commitments.values():
            if fund_id and commitment.get("fund_id") != fund_id:
                continue
            if investor_id and commitment.get("investor_id") != investor_id:
                continue
            if status and commitment.get("status") != status:
                continue
            results.append(commitment)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_commitments",
                "description": "Get commitments with optional filters",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "Filter by fund ID"},
                        "investor_id": {"type": "string", "description": "Filter by investor ID"},
                        "status": {"type": "string", "description": "Filter by status (pending, fulfilled)"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: get_invoices.py
FULL PATH: ./interface_5/get_invoices.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetInvoices(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], commitment_id: Optional[str] = None,
               status: Optional[str] = None, due_date_from: Optional[str] = None,
               due_date_to: Optional[str] = None) -> str:
        invoices = data.get("invoices", {})
        results = []
        
        for invoice in invoices.values():
            if commitment_id and invoice.get("commitment_id") != commitment_id:
                continue
            if status and invoice.get("status") != status:
                continue
            if due_date_from and invoice.get("due_date") < due_date_from:
                continue
            if due_date_to and invoice.get("due_date") > due_date_to:
                continue
            results.append(invoice)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_invoices",
                "description": "Get invoices with optional filters",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "commitment_id": {"type": "string", "description": "Filter by commitment ID"},
                        "status": {"type": "string", "description": "Filter by status (issued, paid)"},
                        "due_date_from": {"type": "string", "description": "Filter invoices due from this date (YYYY-MM-DD)"},
                        "due_date_to": {"type": "string", "description": "Filter invoices due until this date (YYYY-MM-DD)"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: get_nav_records.py
FULL PATH: ./interface_5/get_nav_records.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetNavRecords(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: Optional[str] = None,
               start_date: Optional[str] = None, end_date: Optional[str] = None,
               nav_date: Optional[str] = None) -> str:
        nav_records = data.get("nav_records", {})
        results = []
        
        for nav_record in nav_records.values():
            if fund_id and nav_record.get("fund_id") != fund_id:
                continue
            if nav_date and nav_record.get("nav_date") != nav_date:
                continue
            if start_date and nav_record.get("nav_date", "") < start_date:
                continue
            if end_date and nav_record.get("nav_date", "") > end_date:
                continue
            results.append(nav_record)
        
        # Sort by nav_date descending (most recent first)
        results.sort(key=lambda x: x.get("nav_date", ""), reverse=True)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_nav_records",
                "description": "Get NAV records for performance tracking and reporting",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "Filter by fund ID"},
                        "start_date": {"type": "string", "description": "Filter NAV records from this date onwards"},
                        "end_date": {"type": "string", "description": "Filter NAV records up to this date"},
                        "nav_date": {"type": "string", "description": "Filter by specific NAV date"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: get_payment_history.py
FULL PATH: ./interface_5/get_payment_history.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetPaymentHistory(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], invoice_id: Optional[str] = None,
               subscription_id: Optional[str] = None,
               payment_method: Optional[str] = None, status: Optional[str] = None,
               start_date: Optional[str] = None, end_date: Optional[str] = None) -> str:
        payments = data.get("payments", {})
        results = []
        
        for payment in payments.values():
            if invoice_id and payment.get("invoice_id") != invoice_id:
                continue
            if subscription_id and payment.get("subscription_id") != subscription_id:
                continue
            if payment_method and payment.get("payment_method") != payment_method:
                continue
            if status and payment.get("status") != status:
                continue
            if start_date and payment.get("payment_date", "") < start_date:
                continue
            if end_date and payment.get("payment_date", "") > end_date:
                continue
            results.append(payment)
        
        # Sort by payment_date descending (most recent first)
        results.sort(key=lambda x: x.get("payment_date", ""), reverse=True)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_payment_history",
                "description": "Get payment history with optional filters for reconciliation and audit",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "invoice_id": {"type": "string", "description": "Filter by invoice ID"},
                        "subscription_id": {"type": "string", "description": "Filter by subscription ID"},
                        "payment_method": {"type": "string", "description": "Filter by payment method (wire, cheque, credit_card, bank_transfer)"},
                        "status": {"type": "string", "description": "Filter by status (draft, completed, failed)"},
                        "start_date": {"type": "string", "description": "Filter payments from this date onwards"},
                        "end_date": {"type": "string", "description": "Filter payments up to this date"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: get_subscriptions.py
FULL PATH: ./interface_5/get_subscriptions.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class GetSubscriptions(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: Optional[str] = None, 
               investor_id: Optional[str] = None, status: Optional[str] = None,
               request_assigned_to: Optional[str] = None) -> str:
        subscriptions = data.get("subscriptions", {})
        results = []
        
        for subscription in subscriptions.values():
            if fund_id and subscription.get("fund_id") != fund_id:
                continue
            if investor_id and subscription.get("investor_id") != investor_id:
                continue
            if status and subscription.get("status") != status:
                continue
            if request_assigned_to and subscription.get("request_assigned_to") != request_assigned_to:
                continue
            results.append(subscription)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_subscriptions",
                "description": "Get subscriptions with optional filters",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "Filter by fund ID"},
                        "investor_id": {"type": "string", "description": "Filter by investor ID"},
                        "status": {"type": "string", "description": "Filter by status (pending, approved, cancelled)"},
                        "request_assigned_to": {"type": "string", "description": "Filter by assigned user ID"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: register_payment.py
FULL PATH: ./interface_5/register_payment.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class RegisterPayment(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], invoice_id: str, payment_date: str,
               amount: str, payment_method: str, status: str = "draft") -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        invoices = data.get("invoices", {})
        payments = data.get("payments", {})
        
        # Validate invoice exists
        if str(invoice_id) not in invoices:
            raise ValueError(f"Invoice {invoice_id} not found")
        
        # Validate payment method
        valid_methods = ["wire", "cheque", "credit_card", "bank_transfer"]
        if payment_method not in valid_methods:
            raise ValueError(f"Invalid payment method. Must be one of {valid_methods}")
        
        # Validate status
        valid_statuses = ["draft", "completed", "failed"]
        if status not in valid_statuses:
            raise ValueError(f"Invalid status. Must be one of {valid_statuses}")
        
        payment_id = generate_id(payments)
        timestamp = "2025-10-01T00:00:00"
        
        new_payment = {
            "payment_id": payment_id,
            "invoice_id": invoice_id,
            "payment_date": payment_date,
            "amount": amount,
            "payment_method": payment_method,
            "status": status,
            "created_at": timestamp
        }
        
        payments[str(payment_id)] = new_payment
        return json.dumps({"payment_id": payment_id})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "register_payment",
                "description": "Register a new payment against an invoice",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "invoice_id": {"type": "string", "description": "ID of the invoice"},
                        "payment_date": {"type": "string", "description": "Date of payment"},
                        "amount": {"type": "string", "description": "Payment amount"},
                        "payment_method": {"type": "string", "description": "Payment method (wire, cheque, credit_card, bank_transfer)"},
                        "status": {"type": "string", "description": "Payment status (draft, completed, failed), defaults to draft"}
                    },
                    "required": ["invoice_id", "payment_date", "amount", "payment_method"]
                }
            }
        }


--------------------------------------
FILE: remove_holding.py
FULL PATH: ./interface_5/remove_holding.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class RemoveHolding(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], holding_id: str) -> str:
        portfolio_holdings = data.get("portfolio_holdings", {})
        
        # Validate holding exists
        if str(holding_id) not in portfolio_holdings:
            raise ValueError(f"Holding {holding_id} not found")
        
        # Get holding details before deletion
        deleted_holding = portfolio_holdings.pop(str(holding_id))
        
        return json.dumps({
            "status": "removed",
            "removed_holding": deleted_holding
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "remove_holding",
                "description": "Remove a holding from a portfolio",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "holding_id": {"type": "string", "description": "ID of the holding to remove"}
                    },
                    "required": ["holding_id"]
                }
            }
        }


--------------------------------------
FILE: retrieve_invoices.py
FULL PATH: ./interface_5/retrieve_invoices.py
--------------------------------------

import json
from typing import Any, Dict, Optional, List
from tau_bench.envs.tool import Tool

class RetrieveInvoices(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], invoice_ids: Optional[List[str]] = None) -> str:
        invoices = data.get("invoices", {})
        results = []
        
        if invoice_ids:
            # Retrieve specific invoices
            for invoice_id in invoice_ids:
                if str(invoice_id) in invoices:
                    results.append(invoices[str(invoice_id)])
        else:
            # Retrieve all invoices
            results = list(invoices.values())
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "retrieve_invoices",
                "description": "Retrieve specific invoices by IDs or all invoices",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "invoice_ids": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "List of invoice IDs to retrieve. If not provided, returns all invoices"
                        }
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: summary_of_instrument_types_by_prices.py
FULL PATH: ./interface_5/summary_of_instrument_types_by_prices.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from collections import defaultdict
from tau_bench.envs.tool import Tool

class SummaryOfInstrumentTypesByPrices(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], price_date: Optional[str] = None,
               instrument_type: Optional[str] = None) -> str:
        instruments = data.get("instruments", {})
        instrument_prices = data.get("instrument_prices", {})
        
        # Group by instrument type
        summary = defaultdict(lambda: {
            "count": 0,
            "avg_close_price": 0.0,
            "min_close_price": float('inf'),
            "max_close_price": 0.0,
            "total_close_price": 0.0,
            "instruments": []
        })
        
        for price in instrument_prices.values():
            # Filter by date if specified
            if price_date and price.get("price_date") != price_date:
                continue
            
            instrument_id = price.get("instrument_id")
            if not instrument_id or str(instrument_id) not in instruments:
                continue
            
            instrument = instruments[str(instrument_id)]
            inst_type = instrument.get("instrument_type")
            
            # Filter by instrument type if specified
            if instrument_type and inst_type != instrument_type:
                continue
            
            close_price = float(price.get("close_price", 0))
            
            summary[inst_type]["count"] += 1
            summary[inst_type]["total_close_price"] += close_price
            summary[inst_type]["min_close_price"] = min(summary[inst_type]["min_close_price"], close_price)
            summary[inst_type]["max_close_price"] = max(summary[inst_type]["max_close_price"], close_price)
            
            # Track instrument details
            summary[inst_type]["instruments"].append({
                "instrument_id": instrument_id,
                "ticker": instrument.get("ticker"),
                "name": instrument.get("name"),
                "close_price": close_price,
                "price_date": price.get("price_date")
            })
        
        # Calculate averages and clean up
        result = {}
        for inst_type, data_dict in summary.items():
            if data_dict["count"] > 0:
                data_dict["avg_close_price"] = round(data_dict["total_close_price"] / data_dict["count"], 4)
                if data_dict["min_close_price"] == float('inf'):
                    data_dict["min_close_price"] = 0.0
                # Remove total_close_price as it's not needed in output
                del data_dict["total_close_price"]
                result[inst_type] = data_dict
        
        return json.dumps(result, indent=2)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "summary_of_instrument_types_by_prices",
                "description": "Get a summary of instrument types with pricing statistics",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "price_date": {"type": "string", "description": "Filter by specific price date (YYYY-MM-DD)"},
                        "instrument_type": {"type": "string", "description": "Filter by specific instrument type"}
                    },
                    "required": []
                }
            }
        }


--------------------------------------
FILE: update_invoice.py
FULL PATH: ./interface_5/update_invoice.py
--------------------------------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class UpdateInvoice(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], invoice_id: str, 
               invoice_date: Optional[str] = None, due_date: Optional[str] = None,
               amount: Optional[float] = None, status: Optional[str] = None) -> str:
        invoices = data.get("invoices", {})
        
        # Validate invoice exists
        if str(invoice_id) not in invoices:
            raise ValueError(f"Invoice {invoice_id} not found")
        
        invoice = invoices[str(invoice_id)]
        
        # Validate status if provided
        if status:
            valid_statuses = ["issued", "paid"]
            if status not in valid_statuses:
                raise ValueError(f"Invalid status. Must be one of {valid_statuses}")
        
        # Validate amount if provided
        if amount is not None and amount <= 0:
            raise ValueError("Amount must be positive")
        
        # Update fields
        if invoice_date:
            invoice["invoice_date"] = invoice_date
        if due_date:
            invoice["due_date"] = due_date
        if amount is not None:
            invoice["amount"] = amount
        if status:
            invoice["status"] = status
        
        invoice["updated_at"] = "2025-10-01T00:00:00"
        
        return json.dumps(invoice)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_invoice",
                "description": "Update an existing invoice",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "invoice_id": {"type": "string", "description": "ID of the invoice to update"},
                        "invoice_date": {"type": "string", "description": "New invoice date in YYYY-MM-DD format"},
                        "due_date": {"type": "string", "description": "New due date in YYYY-MM-DD format"},
                        "amount": {"type": "number", "description": "New invoice amount"},
                        "status": {"type": "string", "description": "New status (issued, paid)"}
                    },
                    "required": ["invoice_id"]
                }
            }
        }


--------------------------------------
FILE: update_nav_record_value.py
FULL PATH: ./interface_5/update_nav_record_value.py
--------------------------------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class UpdateNavRecordValue(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], nav_id: str, nav_value: str) -> str:
        nav_records = data.get("nav_records", {})
        
        # Validate NAV record exists
        if str(nav_id) not in nav_records:
            raise ValueError(f"NAV record {nav_id} not found")
        
        nav_record = nav_records[str(nav_id)]
        old_value = nav_record.get("nav_value")
        
        # Update NAV value and timestamp
        nav_record["nav_value"] = nav_value
        nav_record["updated_at"] = "2025-10-01T00:00:00"
        
        return json.dumps({
            "nav_id": nav_id,
            "fund_id": nav_record.get("fund_id"),
            "nav_date": nav_record.get("nav_date"),
            "old_nav_value": old_value,
            "new_nav_value": nav_value,
            "updated_at": nav_record.get("updated_at")
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_nav_record_value",
                "description": "Update NAV record value for valuation adjustments",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "nav_id": {"type": "string", "description": "ID of the NAV record to update"},
                        "nav_value": {"type": "string", "description": "New NAV value"}
                    },
                    "required": ["nav_id", "nav_value"]
                }
            }
        }




=== END OF FILE LISTING ===
